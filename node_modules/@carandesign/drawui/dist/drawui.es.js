import st, { createContext as nt, useContext as rt, useRef as E, useState as U, useEffect as C } from "react";
var ce = { exports: {} }, Y = {};
var je;
function ot() {
  if (je) return Y;
  je = 1;
  var o = /* @__PURE__ */ Symbol.for("react.transitional.element"), e = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(s, t, r) {
    var i = null;
    if (r !== void 0 && (i = "" + r), t.key !== void 0 && (i = "" + t.key), "key" in t) {
      r = {};
      for (var a in t)
        a !== "key" && (r[a] = t[a]);
    } else r = t;
    return t = r.ref, {
      $$typeof: o,
      type: s,
      key: i,
      ref: t !== void 0 ? t : null,
      props: r
    };
  }
  return Y.Fragment = e, Y.jsx = n, Y.jsxs = n, Y;
}
var B = {};
var $e;
function at() {
  return $e || ($e = 1, process.env.NODE_ENV !== "production" && (function() {
    function o(p) {
      if (p == null) return null;
      if (typeof p == "function")
        return p.$$typeof === re ? null : p.displayName || p.name || null;
      if (typeof p == "string") return p;
      switch (p) {
        case b:
          return "Fragment";
        case y:
          return "Profiler";
        case v:
          return "StrictMode";
        case ee:
          return "Suspense";
        case te:
          return "SuspenseList";
        case ne:
          return "Activity";
      }
      if (typeof p == "object")
        switch (typeof p.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), p.$$typeof) {
          case m:
            return "Portal";
          case G:
            return p.displayName || "Context";
          case z:
            return (p._context.displayName || "Context") + ".Consumer";
          case K:
            var M = p.render;
            return p = p.displayName, p || (p = M.displayName || M.name || "", p = p !== "" ? "ForwardRef(" + p + ")" : "ForwardRef"), p;
          case se:
            return M = p.displayName || null, M !== null ? M : o(p.type) || "Memo";
          case $:
            M = p._payload, p = p._init;
            try {
              return o(p(M));
            } catch {
            }
        }
      return null;
    }
    function e(p) {
      return "" + p;
    }
    function n(p) {
      try {
        e(p);
        var M = !1;
      } catch {
        M = !0;
      }
      if (M) {
        M = console;
        var _ = M.error, P = typeof Symbol == "function" && Symbol.toStringTag && p[Symbol.toStringTag] || p.constructor.name || "Object";
        return _.call(
          M,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          P
        ), e(p);
      }
    }
    function s(p) {
      if (p === b) return "<>";
      if (typeof p == "object" && p !== null && p.$$typeof === $)
        return "<...>";
      try {
        var M = o(p);
        return M ? "<" + M + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function t() {
      var p = x.A;
      return p === null ? null : p.getOwner();
    }
    function r() {
      return Error("react-stack-top-frame");
    }
    function i(p) {
      if (S.call(p, "key")) {
        var M = Object.getOwnPropertyDescriptor(p, "key").get;
        if (M && M.isReactWarning) return !1;
      }
      return p.key !== void 0;
    }
    function a(p, M) {
      function _() {
        D || (D = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          M
        ));
      }
      _.isReactWarning = !0, Object.defineProperty(p, "key", {
        get: _,
        configurable: !0
      });
    }
    function l() {
      var p = o(this.type);
      return F[p] || (F[p] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), p = this.props.ref, p !== void 0 ? p : null;
    }
    function u(p, M, _, P, ie, we) {
      var T = _.ref;
      return p = {
        $$typeof: g,
        type: p,
        key: M,
        props: _,
        _owner: P
      }, (T !== void 0 ? T : null) !== null ? Object.defineProperty(p, "ref", {
        enumerable: !1,
        get: l
      }) : Object.defineProperty(p, "ref", { enumerable: !1, value: null }), p._store = {}, Object.defineProperty(p._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(p, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(p, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ie
      }), Object.defineProperty(p, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: we
      }), Object.freeze && (Object.freeze(p.props), Object.freeze(p)), p;
    }
    function c(p, M, _, P, ie, we) {
      var T = M.children;
      if (T !== void 0)
        if (P)
          if (j(T)) {
            for (P = 0; P < T.length; P++)
              h(T[P]);
            Object.freeze && Object.freeze(T);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else h(T);
      if (S.call(M, "key")) {
        T = o(p);
        var H = Object.keys(M).filter(function(tt) {
          return tt !== "key";
        });
        P = 0 < H.length ? "{key: someKey, " + H.join(": ..., ") + ": ...}" : "{key: someKey}", V[T + P] || (H = 0 < H.length ? "{" + H.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          P,
          T,
          H,
          T
        ), V[T + P] = !0);
      }
      if (T = null, _ !== void 0 && (n(_), T = "" + _), i(M) && (n(M.key), T = "" + M.key), "key" in M) {
        _ = {};
        for (var ye in M)
          ye !== "key" && (_[ye] = M[ye]);
      } else _ = M;
      return T && a(
        _,
        typeof p == "function" ? p.displayName || p.name || "Unknown" : p
      ), u(
        p,
        T,
        _,
        t(),
        ie,
        we
      );
    }
    function h(p) {
      f(p) ? p._store && (p._store.validated = 1) : typeof p == "object" && p !== null && p.$$typeof === $ && (p._payload.status === "fulfilled" ? f(p._payload.value) && p._payload.value._store && (p._payload.value._store.validated = 1) : p._store && (p._store.validated = 1));
    }
    function f(p) {
      return typeof p == "object" && p !== null && p.$$typeof === g;
    }
    var d = st, g = /* @__PURE__ */ Symbol.for("react.transitional.element"), m = /* @__PURE__ */ Symbol.for("react.portal"), b = /* @__PURE__ */ Symbol.for("react.fragment"), v = /* @__PURE__ */ Symbol.for("react.strict_mode"), y = /* @__PURE__ */ Symbol.for("react.profiler"), z = /* @__PURE__ */ Symbol.for("react.consumer"), G = /* @__PURE__ */ Symbol.for("react.context"), K = /* @__PURE__ */ Symbol.for("react.forward_ref"), ee = /* @__PURE__ */ Symbol.for("react.suspense"), te = /* @__PURE__ */ Symbol.for("react.suspense_list"), se = /* @__PURE__ */ Symbol.for("react.memo"), $ = /* @__PURE__ */ Symbol.for("react.lazy"), ne = /* @__PURE__ */ Symbol.for("react.activity"), re = /* @__PURE__ */ Symbol.for("react.client.reference"), x = d.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, S = Object.prototype.hasOwnProperty, j = Array.isArray, I = console.createTask ? console.createTask : function() {
      return null;
    };
    d = {
      react_stack_bottom_frame: function(p) {
        return p();
      }
    };
    var D, F = {}, oe = d.react_stack_bottom_frame.bind(
      d,
      r
    )(), ae = I(s(r)), V = {};
    B.Fragment = b, B.jsx = function(p, M, _) {
      var P = 1e4 > x.recentlyCreatedOwnerStacks++;
      return c(
        p,
        M,
        _,
        !1,
        P ? Error("react-stack-top-frame") : oe,
        P ? I(s(p)) : ae
      );
    }, B.jsxs = function(p, M, _) {
      var P = 1e4 > x.recentlyCreatedOwnerStacks++;
      return c(
        p,
        M,
        _,
        !0,
        P ? Error("react-stack-top-frame") : oe,
        P ? I(s(p)) : ae
      );
    };
  })()), B;
}
var De;
function it() {
  return De || (De = 1, process.env.NODE_ENV === "production" ? ce.exports = ot() : ce.exports = at()), ce.exports;
}
var w = it();
function Te(o, e, n) {
  if (o && o.length) {
    const [s, t] = e, r = Math.PI / 180 * n, i = Math.cos(r), a = Math.sin(r);
    for (const l of o) {
      const [u, c] = l;
      l[0] = (u - s) * i - (c - t) * a + s, l[1] = (u - s) * a + (c - t) * i + t;
    }
  }
}
function ct(o, e, n) {
  const s = [];
  o.forEach((t) => s.push(...t)), Te(s, e, n);
}
function lt(o, e) {
  return o[0] === e[0] && o[1] === e[1];
}
function ut(o, e, n, s = 1) {
  const t = n, r = Math.max(e, 0.1), i = o[0] && o[0][0] && typeof o[0][0] == "number" ? [o] : o, a = [0, 0];
  if (t)
    for (const u of i)
      Te(u, a, t);
  const l = ht(i, r, s);
  if (t) {
    for (const u of i)
      Te(u, a, -t);
    ct(l, a, -t);
  }
  return l;
}
function ht(o, e, n) {
  const s = [];
  for (const u of o) {
    const c = [...u];
    lt(c[0], c[c.length - 1]) || c.push([c[0][0], c[0][1]]), c.length > 2 && s.push(c);
  }
  const t = [];
  e = Math.max(e, 0.1);
  const r = [];
  for (const u of s)
    for (let c = 0; c < u.length - 1; c++) {
      const h = u[c], f = u[c + 1];
      if (h[1] !== f[1]) {
        const d = Math.min(h[1], f[1]);
        r.push({
          ymin: d,
          ymax: Math.max(h[1], f[1]),
          x: d === h[1] ? h[0] : f[0],
          islope: (f[0] - h[0]) / (f[1] - h[1])
        });
      }
    }
  if (r.sort((u, c) => u.ymin < c.ymin ? -1 : u.ymin > c.ymin ? 1 : u.x < c.x ? -1 : u.x > c.x ? 1 : u.ymax === c.ymax ? 0 : (u.ymax - c.ymax) / Math.abs(u.ymax - c.ymax)), !r.length)
    return t;
  let i = [], a = r[0].ymin, l = 0;
  for (; i.length || r.length; ) {
    if (r.length) {
      let u = -1;
      for (let h = 0; h < r.length && !(r[h].ymin > a); h++)
        u = h;
      r.splice(0, u + 1).forEach((h) => {
        i.push({ s: a, edge: h });
      });
    }
    if (i = i.filter((u) => !(u.edge.ymax <= a)), i.sort((u, c) => u.edge.x === c.edge.x ? 0 : (u.edge.x - c.edge.x) / Math.abs(u.edge.x - c.edge.x)), (n !== 1 || l % e === 0) && i.length > 1)
      for (let u = 0; u < i.length; u = u + 2) {
        const c = u + 1;
        if (c >= i.length)
          break;
        const h = i[u].edge, f = i[c].edge;
        t.push([
          [Math.round(h.x), a],
          [Math.round(f.x), a]
        ]);
      }
    a += n, i.forEach((u) => {
      u.edge.x = u.edge.x + n * u.edge.islope;
    }), l++;
  }
  return t;
}
function Q(o, e) {
  var n;
  const s = e.hachureAngle + 90;
  let t = e.hachureGap;
  t < 0 && (t = e.strokeWidth * 4), t = Math.round(Math.max(t, 0.1));
  let r = 1;
  return e.roughness >= 1 && (((n = e.randomizer) === null || n === void 0 ? void 0 : n.next()) || Math.random()) > 0.7 && (r = t), ut(o, t, s, r || 1);
}
class Le {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, n) {
    return this._fillPolygons(e, n);
  }
  _fillPolygons(e, n) {
    const s = Q(e, n);
    return { type: "fillSketch", ops: this.renderLines(s, n) };
  }
  renderLines(e, n) {
    const s = [];
    for (const t of e)
      s.push(...this.helper.doubleLineOps(t[0][0], t[0][1], t[1][0], t[1][1], n));
    return s;
  }
}
function Me(o) {
  const e = o[0], n = o[1];
  return Math.sqrt(Math.pow(e[0] - n[0], 2) + Math.pow(e[1] - n[1], 2));
}
class ft extends Le {
  fillPolygons(e, n) {
    let s = n.hachureGap;
    s < 0 && (s = n.strokeWidth * 4), s = Math.max(s, 0.1);
    const t = Object.assign({}, n, { hachureGap: s }), r = Q(e, t), i = Math.PI / 180 * n.hachureAngle, a = [], l = s * 0.5 * Math.cos(i), u = s * 0.5 * Math.sin(i);
    for (const [h, f] of r)
      Me([h, f]) && a.push([
        [h[0] - l, h[1] + u],
        [...f]
      ], [
        [h[0] + l, h[1] - u],
        [...f]
      ]);
    return { type: "fillSketch", ops: this.renderLines(a, n) };
  }
}
class dt extends Le {
  fillPolygons(e, n) {
    const s = this._fillPolygons(e, n), t = Object.assign({}, n, { hachureAngle: n.hachureAngle + 90 }), r = this._fillPolygons(e, t);
    return s.ops = s.ops.concat(r.ops), s;
  }
}
class pt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, n) {
    n = Object.assign({}, n, { hachureAngle: 0 });
    const s = Q(e, n);
    return this.dotsOnLines(s, n);
  }
  dotsOnLines(e, n) {
    const s = [];
    let t = n.hachureGap;
    t < 0 && (t = n.strokeWidth * 4), t = Math.max(t, 0.1);
    let r = n.fillWeight;
    r < 0 && (r = n.strokeWidth / 2);
    const i = t / 4;
    for (const a of e) {
      const l = Me(a), u = l / t, c = Math.ceil(u) - 1, h = l - c * t, f = (a[0][0] + a[1][0]) / 2 - t / 4, d = Math.min(a[0][1], a[1][1]);
      for (let g = 0; g < c; g++) {
        const m = d + h + g * t, b = f - i + Math.random() * 2 * i, v = m - i + Math.random() * 2 * i, y = this.helper.ellipse(b, v, r, r, n);
        s.push(...y.ops);
      }
    }
    return { type: "fillSketch", ops: s };
  }
}
class gt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, n) {
    const s = Q(e, n);
    return { type: "fillSketch", ops: this.dashedLine(s, n) };
  }
  dashedLine(e, n) {
    const s = n.dashOffset < 0 ? n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap : n.dashOffset, t = n.dashGap < 0 ? n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap : n.dashGap, r = [];
    return e.forEach((i) => {
      const a = Me(i), l = Math.floor(a / (s + t)), u = (a + t - l * (s + t)) / 2;
      let c = i[0], h = i[1];
      c[0] > h[0] && (c = i[1], h = i[0]);
      const f = Math.atan((h[1] - c[1]) / (h[0] - c[0]));
      for (let d = 0; d < l; d++) {
        const g = d * (s + t), m = g + s, b = [c[0] + g * Math.cos(f) + u * Math.cos(f), c[1] + g * Math.sin(f) + u * Math.sin(f)], v = [c[0] + m * Math.cos(f) + u * Math.cos(f), c[1] + m * Math.sin(f) + u * Math.sin(f)];
        r.push(...this.helper.doubleLineOps(b[0], b[1], v[0], v[1], n));
      }
    }), r;
  }
}
class mt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, n) {
    const s = n.hachureGap < 0 ? n.strokeWidth * 4 : n.hachureGap, t = n.zigzagOffset < 0 ? s : n.zigzagOffset;
    n = Object.assign({}, n, { hachureGap: s + t });
    const r = Q(e, n);
    return { type: "fillSketch", ops: this.zigzagLines(r, t, n) };
  }
  zigzagLines(e, n, s) {
    const t = [];
    return e.forEach((r) => {
      const i = Me(r), a = Math.round(i / (2 * n));
      let l = r[0], u = r[1];
      l[0] > u[0] && (l = r[1], u = r[0]);
      const c = Math.atan((u[1] - l[1]) / (u[0] - l[0]));
      for (let h = 0; h < a; h++) {
        const f = h * 2 * n, d = (h + 1) * 2 * n, g = Math.sqrt(2 * Math.pow(n, 2)), m = [l[0] + f * Math.cos(c), l[1] + f * Math.sin(c)], b = [l[0] + d * Math.cos(c), l[1] + d * Math.sin(c)], v = [m[0] + g * Math.cos(c + Math.PI / 4), m[1] + g * Math.sin(c + Math.PI / 4)];
        t.push(...this.helper.doubleLineOps(m[0], m[1], v[0], v[1], s), ...this.helper.doubleLineOps(v[0], v[1], b[0], b[1], s));
      }
    }), t;
  }
}
const O = {};
function kt(o, e) {
  let n = o.fillStyle || "hachure";
  if (!O[n])
    switch (n) {
      case "zigzag":
        O[n] || (O[n] = new ft(e));
        break;
      case "cross-hatch":
        O[n] || (O[n] = new dt(e));
        break;
      case "dots":
        O[n] || (O[n] = new pt(e));
        break;
      case "dashed":
        O[n] || (O[n] = new gt(e));
        break;
      case "zigzag-line":
        O[n] || (O[n] = new mt(e));
        break;
      default:
        n = "hachure", O[n] || (O[n] = new Le(e));
        break;
    }
  return O[n];
}
function bt() {
  return Math.floor(Math.random() * 2 ** 31);
}
class vt {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
}
const Mt = 0, xe = 1, Be = 2, le = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function wt(o) {
  const e = new Array();
  for (; o !== ""; )
    if (o.match(/^([ \t\r\n,]+)/))
      o = o.substr(RegExp.$1.length);
    else if (o.match(/^([aAcChHlLmMqQsStTvVzZ])/))
      e[e.length] = { type: Mt, text: RegExp.$1 }, o = o.substr(RegExp.$1.length);
    else if (o.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))
      e[e.length] = { type: xe, text: `${parseFloat(RegExp.$1)}` }, o = o.substr(RegExp.$1.length);
    else
      return [];
  return e[e.length] = { type: Be, text: "" }, e;
}
function _e(o, e) {
  return o.type === e;
}
function Ae(o) {
  const e = [], n = wt(o);
  let s = "BOD", t = 0, r = n[t];
  for (; !_e(r, Be); ) {
    let i = 0;
    const a = [];
    if (s === "BOD")
      if (r.text === "M" || r.text === "m")
        t++, i = le[r.text], s = r.text;
      else
        return Ae("M0,0" + o);
    else _e(r, xe) ? i = le[s] : (t++, i = le[r.text], s = r.text);
    if (t + i < n.length) {
      for (let l = t; l < t + i; l++) {
        const u = n[l];
        if (_e(u, xe))
          a[a.length] = +u.text;
        else
          throw new Error("Param not a number: " + s + "," + u.text);
      }
      if (typeof le[s] == "number") {
        const l = { key: s, data: a };
        e.push(l), t += i, r = n[t], s === "M" && (s = "L"), s === "m" && (s = "l");
      } else
        throw new Error("Bad segment: " + s);
    } else
      throw new Error("Path data ended short");
  }
  return e;
}
function Ze(o) {
  let e = 0, n = 0, s = 0, t = 0;
  const r = [];
  for (const { key: i, data: a } of o)
    switch (i) {
      case "M":
        r.push({ key: "M", data: [...a] }), [e, n] = a, [s, t] = a;
        break;
      case "m":
        e += a[0], n += a[1], r.push({ key: "M", data: [e, n] }), s = e, t = n;
        break;
      case "L":
        r.push({ key: "L", data: [...a] }), [e, n] = a;
        break;
      case "l":
        e += a[0], n += a[1], r.push({ key: "L", data: [e, n] });
        break;
      case "C":
        r.push({ key: "C", data: [...a] }), e = a[4], n = a[5];
        break;
      case "c": {
        const l = a.map((u, c) => c % 2 ? u + n : u + e);
        r.push({ key: "C", data: l }), e = l[4], n = l[5];
        break;
      }
      case "Q":
        r.push({ key: "Q", data: [...a] }), e = a[2], n = a[3];
        break;
      case "q": {
        const l = a.map((u, c) => c % 2 ? u + n : u + e);
        r.push({ key: "Q", data: l }), e = l[2], n = l[3];
        break;
      }
      case "A":
        r.push({ key: "A", data: [...a] }), e = a[5], n = a[6];
        break;
      case "a":
        e += a[5], n += a[6], r.push({ key: "A", data: [a[0], a[1], a[2], a[3], a[4], e, n] });
        break;
      case "H":
        r.push({ key: "H", data: [...a] }), e = a[0];
        break;
      case "h":
        e += a[0], r.push({ key: "H", data: [e] });
        break;
      case "V":
        r.push({ key: "V", data: [...a] }), n = a[0];
        break;
      case "v":
        n += a[0], r.push({ key: "V", data: [n] });
        break;
      case "S":
        r.push({ key: "S", data: [...a] }), e = a[2], n = a[3];
        break;
      case "s": {
        const l = a.map((u, c) => c % 2 ? u + n : u + e);
        r.push({ key: "S", data: l }), e = l[2], n = l[3];
        break;
      }
      case "T":
        r.push({ key: "T", data: [...a] }), e = a[0], n = a[1];
        break;
      case "t":
        e += a[0], n += a[1], r.push({ key: "T", data: [e, n] });
        break;
      case "Z":
      case "z":
        r.push({ key: "Z", data: [] }), e = s, n = t;
        break;
    }
  return r;
}
function Xe(o) {
  const e = [];
  let n = "", s = 0, t = 0, r = 0, i = 0, a = 0, l = 0;
  for (const { key: u, data: c } of o) {
    switch (u) {
      case "M":
        e.push({ key: "M", data: [...c] }), [s, t] = c, [r, i] = c;
        break;
      case "C":
        e.push({ key: "C", data: [...c] }), s = c[4], t = c[5], a = c[2], l = c[3];
        break;
      case "L":
        e.push({ key: "L", data: [...c] }), [s, t] = c;
        break;
      case "H":
        s = c[0], e.push({ key: "L", data: [s, t] });
        break;
      case "V":
        t = c[0], e.push({ key: "L", data: [s, t] });
        break;
      case "S": {
        let h = 0, f = 0;
        n === "C" || n === "S" ? (h = s + (s - a), f = t + (t - l)) : (h = s, f = t), e.push({ key: "C", data: [h, f, ...c] }), a = c[0], l = c[1], s = c[2], t = c[3];
        break;
      }
      case "T": {
        const [h, f] = c;
        let d = 0, g = 0;
        n === "Q" || n === "T" ? (d = s + (s - a), g = t + (t - l)) : (d = s, g = t);
        const m = s + 2 * (d - s) / 3, b = t + 2 * (g - t) / 3, v = h + 2 * (d - h) / 3, y = f + 2 * (g - f) / 3;
        e.push({ key: "C", data: [m, b, v, y, h, f] }), a = d, l = g, s = h, t = f;
        break;
      }
      case "Q": {
        const [h, f, d, g] = c, m = s + 2 * (h - s) / 3, b = t + 2 * (f - t) / 3, v = d + 2 * (h - d) / 3, y = g + 2 * (f - g) / 3;
        e.push({ key: "C", data: [m, b, v, y, d, g] }), a = h, l = f, s = d, t = g;
        break;
      }
      case "A": {
        const h = Math.abs(c[0]), f = Math.abs(c[1]), d = c[2], g = c[3], m = c[4], b = c[5], v = c[6];
        h === 0 || f === 0 ? (e.push({ key: "C", data: [s, t, b, v, b, v] }), s = b, t = v) : (s !== b || t !== v) && (Ue(s, t, b, v, h, f, d, g, m).forEach(function(z) {
          e.push({ key: "C", data: z });
        }), s = b, t = v);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), s = r, t = i;
        break;
    }
    n = u;
  }
  return e;
}
function yt(o) {
  return Math.PI * o / 180;
}
function Z(o, e, n) {
  const s = o * Math.cos(n) - e * Math.sin(n), t = o * Math.sin(n) + e * Math.cos(n);
  return [s, t];
}
function Ue(o, e, n, s, t, r, i, a, l, u) {
  const c = yt(i);
  let h = [], f = 0, d = 0, g = 0, m = 0;
  if (u)
    [f, d, g, m] = u;
  else {
    [o, e] = Z(o, e, -c), [n, s] = Z(n, s, -c);
    const x = (o - n) / 2, S = (e - s) / 2;
    let j = x * x / (t * t) + S * S / (r * r);
    j > 1 && (j = Math.sqrt(j), t = j * t, r = j * r);
    const I = a === l ? -1 : 1, D = t * t, F = r * r, oe = D * F - D * S * S - F * x * x, ae = D * S * S + F * x * x, V = I * Math.sqrt(Math.abs(oe / ae));
    g = V * t * S / r + (o + n) / 2, m = V * -r * x / t + (e + s) / 2, f = Math.asin(parseFloat(((e - m) / r).toFixed(9))), d = Math.asin(parseFloat(((s - m) / r).toFixed(9))), o < g && (f = Math.PI - f), n < g && (d = Math.PI - d), f < 0 && (f = Math.PI * 2 + f), d < 0 && (d = Math.PI * 2 + d), l && f > d && (f = f - Math.PI * 2), !l && d > f && (d = d - Math.PI * 2);
  }
  let b = d - f;
  if (Math.abs(b) > Math.PI * 120 / 180) {
    const x = d, S = n, j = s;
    l && d > f ? d = f + Math.PI * 120 / 180 * 1 : d = f + Math.PI * 120 / 180 * -1, n = g + t * Math.cos(d), s = m + r * Math.sin(d), h = Ue(n, s, S, j, t, r, i, 0, l, [d, x, g, m]);
  }
  b = d - f;
  const v = Math.cos(f), y = Math.sin(f), z = Math.cos(d), G = Math.sin(d), K = Math.tan(b / 4), ee = 4 / 3 * t * K, te = 4 / 3 * r * K, se = [o, e], $ = [o + ee * y, e - te * v], ne = [n + ee * G, s - te * z], re = [n, s];
  if ($[0] = 2 * se[0] - $[0], $[1] = 2 * se[1] - $[1], u)
    return [$, ne, re].concat(h);
  {
    h = [$, ne, re].concat(h);
    const x = [];
    for (let S = 0; S < h.length; S += 3) {
      const j = Z(h[S][0], h[S][1], c), I = Z(h[S + 1][0], h[S + 1][1], c), D = Z(h[S + 2][0], h[S + 2][1], c);
      x.push([j[0], j[1], I[0], I[1], D[0], D[1]]);
    }
    return x;
  }
}
const _t = {
  randOffset: Ot,
  randOffsetWithRange: Et,
  ellipse: Tt,
  doubleLineOps: Rt
};
function Qe(o, e, n, s, t) {
  return { type: "path", ops: N(o, e, n, s, t) };
}
function de(o, e, n) {
  const s = (o || []).length;
  if (s > 2) {
    const t = [];
    for (let r = 0; r < s - 1; r++)
      t.push(...N(o[r][0], o[r][1], o[r + 1][0], o[r + 1][1], n));
    return e && t.push(...N(o[s - 1][0], o[s - 1][1], o[0][0], o[0][1], n)), { type: "path", ops: t };
  } else if (s === 2)
    return Qe(o[0][0], o[0][1], o[1][0], o[1][1], n);
  return { type: "path", ops: [] };
}
function St(o, e) {
  return de(o, !0, e);
}
function Pt(o, e, n, s, t) {
  const r = [
    [o, e],
    [o + n, e],
    [o + n, e + s],
    [o, e + s]
  ];
  return St(r, t);
}
function ze(o, e) {
  if (o.length) {
    const s = typeof o[0][0] == "number" ? [o] : o, t = ue(s[0], 1 * (1 + e.roughness * 0.2), e), r = e.disableMultiStroke ? [] : ue(s[0], 1.5 * (1 + e.roughness * 0.22), We(e));
    for (let i = 1; i < s.length; i++) {
      const a = s[i];
      if (a.length) {
        const l = ue(a, 1 * (1 + e.roughness * 0.2), e), u = e.disableMultiStroke ? [] : ue(a, 1.5 * (1 + e.roughness * 0.22), We(e));
        for (const c of l)
          c.op !== "move" && t.push(c);
        for (const c of u)
          c.op !== "move" && r.push(c);
      }
    }
    return { type: "path", ops: t.concat(r) };
  }
  return { type: "path", ops: [] };
}
function Tt(o, e, n, s, t) {
  const r = Je(n, s, t);
  return Oe(o, e, t, r).opset;
}
function Je(o, e, n) {
  const s = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(o / 2, 2) + Math.pow(e / 2, 2)) / 2)), t = Math.ceil(Math.max(n.curveStepCount, n.curveStepCount / Math.sqrt(200) * s)), r = Math.PI * 2 / t;
  let i = Math.abs(o / 2), a = Math.abs(e / 2);
  const l = 1 - n.curveFitting;
  return i += k(i * l, n), a += k(a * l, n), { increment: r, rx: i, ry: a };
}
function Oe(o, e, n, s) {
  const [t, r] = Fe(s.increment, o, e, s.rx, s.ry, 1, s.increment * me(0.1, me(0.4, 1, n), n), n);
  let i = ke(t, null, n);
  if (!n.disableMultiStroke && n.roughness !== 0) {
    const [a] = Fe(s.increment, o, e, s.rx, s.ry, 1.5, 0, n), l = ke(a, null, n);
    i = i.concat(l);
  }
  return {
    estimatedPoints: r,
    opset: { type: "path", ops: i }
  };
}
function Ie(o, e, n, s, t, r, i, a, l) {
  const u = o, c = e;
  let h = Math.abs(n / 2), f = Math.abs(s / 2);
  h += k(h * 0.01, l), f += k(f * 0.01, l);
  let d = t, g = r;
  for (; d < 0; )
    d += Math.PI * 2, g += Math.PI * 2;
  g - d > Math.PI * 2 && (d = 0, g = Math.PI * 2);
  const m = Math.PI * 2 / l.curveStepCount, b = Math.min(m / 2, (g - d) / 2), v = He(b, u, c, h, f, d, g, 1, l);
  if (!l.disableMultiStroke) {
    const y = He(b, u, c, h, f, d, g, 1.5, l);
    v.push(...y);
  }
  return i && (a ? v.push(...N(u, c, u + h * Math.cos(d), c + f * Math.sin(d), l), ...N(u, c, u + h * Math.cos(g), c + f * Math.sin(g), l)) : v.push({ op: "lineTo", data: [u, c] }, { op: "lineTo", data: [u + h * Math.cos(d), c + f * Math.sin(d)] })), { type: "path", ops: v };
}
function Ne(o, e) {
  const n = Xe(Ze(Ae(o))), s = [];
  let t = [0, 0], r = [0, 0];
  for (const { key: i, data: a } of n)
    switch (i) {
      case "M": {
        r = [a[0], a[1]], t = [a[0], a[1]];
        break;
      }
      case "L":
        s.push(...N(r[0], r[1], a[0], a[1], e)), r = [a[0], a[1]];
        break;
      case "C": {
        const [l, u, c, h, f, d] = a;
        s.push(...Ct(l, u, c, h, f, d, r, e)), r = [f, d];
        break;
      }
      case "Z":
        s.push(...N(r[0], r[1], t[0], t[1], e)), r = [t[0], t[1]];
        break;
    }
  return { type: "path", ops: s };
}
function Se(o, e) {
  const n = [];
  for (const s of o)
    if (s.length) {
      const t = e.maxRandomnessOffset || 0, r = s.length;
      if (r > 2) {
        n.push({ op: "move", data: [s[0][0] + k(t, e), s[0][1] + k(t, e)] });
        for (let i = 1; i < r; i++)
          n.push({ op: "lineTo", data: [s[i][0] + k(t, e), s[i][1] + k(t, e)] });
      }
    }
  return { type: "fillPath", ops: n };
}
function q(o, e) {
  return kt(e, _t).fillPolygons(o, e);
}
function xt(o, e, n, s, t, r, i) {
  const a = o, l = e;
  let u = Math.abs(n / 2), c = Math.abs(s / 2);
  u += k(u * 0.01, i), c += k(c * 0.01, i);
  let h = t, f = r;
  for (; h < 0; )
    h += Math.PI * 2, f += Math.PI * 2;
  f - h > Math.PI * 2 && (h = 0, f = Math.PI * 2);
  const d = (f - h) / i.curveStepCount, g = [];
  for (let m = h; m <= f; m = m + d)
    g.push([a + u * Math.cos(m), l + c * Math.sin(m)]);
  return g.push([a + u * Math.cos(f), l + c * Math.sin(f)]), g.push([a, l]), q([g], i);
}
function Ot(o, e) {
  return k(o, e);
}
function Et(o, e, n) {
  return me(o, e, n);
}
function Rt(o, e, n, s, t) {
  return N(o, e, n, s, t, !0);
}
function We(o) {
  const e = Object.assign({}, o);
  return e.randomizer = void 0, o.seed && (e.seed = o.seed + 1), e;
}
function Ke(o) {
  return o.randomizer || (o.randomizer = new vt(o.seed || 0)), o.randomizer.next();
}
function me(o, e, n, s = 1) {
  return n.roughness * s * (Ke(n) * (e - o) + o);
}
function k(o, e, n = 1) {
  return me(-o, o, e, n);
}
function N(o, e, n, s, t, r = !1) {
  const i = r ? t.disableMultiStrokeFill : t.disableMultiStroke, a = Ee(o, e, n, s, t, !0, !1);
  if (i)
    return a;
  const l = Ee(o, e, n, s, t, !0, !0);
  return a.concat(l);
}
function Ee(o, e, n, s, t, r, i) {
  const a = Math.pow(o - n, 2) + Math.pow(e - s, 2), l = Math.sqrt(a);
  let u = 1;
  l < 200 ? u = 1 : l > 500 ? u = 0.4 : u = -16668e-7 * l + 1.233334;
  let c = t.maxRandomnessOffset || 0;
  c * c * 100 > a && (c = l / 10);
  const h = c / 2, f = 0.2 + Ke(t) * 0.2;
  let d = t.bowing * t.maxRandomnessOffset * (s - e) / 200, g = t.bowing * t.maxRandomnessOffset * (o - n) / 200;
  d = k(d, t, u), g = k(g, t, u);
  const m = [], b = () => k(h, t, u), v = () => k(c, t, u), y = t.preserveVertices;
  return i ? m.push({
    op: "move",
    data: [
      o + (y ? 0 : b()),
      e + (y ? 0 : b())
    ]
  }) : m.push({
    op: "move",
    data: [
      o + (y ? 0 : k(c, t, u)),
      e + (y ? 0 : k(c, t, u))
    ]
  }), i ? m.push({
    op: "bcurveTo",
    data: [
      d + o + (n - o) * f + b(),
      g + e + (s - e) * f + b(),
      d + o + 2 * (n - o) * f + b(),
      g + e + 2 * (s - e) * f + b(),
      n + (y ? 0 : b()),
      s + (y ? 0 : b())
    ]
  }) : m.push({
    op: "bcurveTo",
    data: [
      d + o + (n - o) * f + v(),
      g + e + (s - e) * f + v(),
      d + o + 2 * (n - o) * f + v(),
      g + e + 2 * (s - e) * f + v(),
      n + (y ? 0 : v()),
      s + (y ? 0 : v())
    ]
  }), m;
}
function ue(o, e, n) {
  if (!o.length)
    return [];
  const s = [];
  s.push([
    o[0][0] + k(e, n),
    o[0][1] + k(e, n)
  ]), s.push([
    o[0][0] + k(e, n),
    o[0][1] + k(e, n)
  ]);
  for (let t = 1; t < o.length; t++)
    s.push([
      o[t][0] + k(e, n),
      o[t][1] + k(e, n)
    ]), t === o.length - 1 && s.push([
      o[t][0] + k(e, n),
      o[t][1] + k(e, n)
    ]);
  return ke(s, null, n);
}
function ke(o, e, n) {
  const s = o.length, t = [];
  if (s > 3) {
    const r = [], i = 1 - n.curveTightness;
    t.push({ op: "move", data: [o[1][0], o[1][1]] });
    for (let a = 1; a + 2 < s; a++) {
      const l = o[a];
      r[0] = [l[0], l[1]], r[1] = [l[0] + (i * o[a + 1][0] - i * o[a - 1][0]) / 6, l[1] + (i * o[a + 1][1] - i * o[a - 1][1]) / 6], r[2] = [o[a + 1][0] + (i * o[a][0] - i * o[a + 2][0]) / 6, o[a + 1][1] + (i * o[a][1] - i * o[a + 2][1]) / 6], r[3] = [o[a + 1][0], o[a + 1][1]], t.push({ op: "bcurveTo", data: [r[1][0], r[1][1], r[2][0], r[2][1], r[3][0], r[3][1]] });
    }
  } else s === 3 ? (t.push({ op: "move", data: [o[1][0], o[1][1]] }), t.push({
    op: "bcurveTo",
    data: [
      o[1][0],
      o[1][1],
      o[2][0],
      o[2][1],
      o[2][0],
      o[2][1]
    ]
  })) : s === 2 && t.push(...Ee(o[0][0], o[0][1], o[1][0], o[1][1], n, !0, !0));
  return t;
}
function Fe(o, e, n, s, t, r, i, a) {
  const l = a.roughness === 0, u = [], c = [];
  if (l) {
    o = o / 4, c.push([
      e + s * Math.cos(-o),
      n + t * Math.sin(-o)
    ]);
    for (let h = 0; h <= Math.PI * 2; h = h + o) {
      const f = [
        e + s * Math.cos(h),
        n + t * Math.sin(h)
      ];
      u.push(f), c.push(f);
    }
    c.push([
      e + s * Math.cos(0),
      n + t * Math.sin(0)
    ]), c.push([
      e + s * Math.cos(o),
      n + t * Math.sin(o)
    ]);
  } else {
    const h = k(0.5, a) - Math.PI / 2;
    c.push([
      k(r, a) + e + 0.9 * s * Math.cos(h - o),
      k(r, a) + n + 0.9 * t * Math.sin(h - o)
    ]);
    const f = Math.PI * 2 + h - 0.01;
    for (let d = h; d < f; d = d + o) {
      const g = [
        k(r, a) + e + s * Math.cos(d),
        k(r, a) + n + t * Math.sin(d)
      ];
      u.push(g), c.push(g);
    }
    c.push([
      k(r, a) + e + s * Math.cos(h + Math.PI * 2 + i * 0.5),
      k(r, a) + n + t * Math.sin(h + Math.PI * 2 + i * 0.5)
    ]), c.push([
      k(r, a) + e + 0.98 * s * Math.cos(h + i),
      k(r, a) + n + 0.98 * t * Math.sin(h + i)
    ]), c.push([
      k(r, a) + e + 0.9 * s * Math.cos(h + i * 0.5),
      k(r, a) + n + 0.9 * t * Math.sin(h + i * 0.5)
    ]);
  }
  return [c, u];
}
function He(o, e, n, s, t, r, i, a, l) {
  const u = r + k(0.1, l), c = [];
  c.push([
    k(a, l) + e + 0.9 * s * Math.cos(u - o),
    k(a, l) + n + 0.9 * t * Math.sin(u - o)
  ]);
  for (let h = u; h <= i; h = h + o)
    c.push([
      k(a, l) + e + s * Math.cos(h),
      k(a, l) + n + t * Math.sin(h)
    ]);
  return c.push([
    e + s * Math.cos(i),
    n + t * Math.sin(i)
  ]), c.push([
    e + s * Math.cos(i),
    n + t * Math.sin(i)
  ]), ke(c, null, l);
}
function Ct(o, e, n, s, t, r, i, a) {
  const l = [], u = [a.maxRandomnessOffset || 1, (a.maxRandomnessOffset || 1) + 0.3];
  let c = [0, 0];
  const h = a.disableMultiStroke ? 1 : 2, f = a.preserveVertices;
  for (let d = 0; d < h; d++)
    d === 0 ? l.push({ op: "move", data: [i[0], i[1]] }) : l.push({ op: "move", data: [i[0] + (f ? 0 : k(u[0], a)), i[1] + (f ? 0 : k(u[0], a))] }), c = f ? [t, r] : [t + k(u[d], a), r + k(u[d], a)], l.push({
      op: "bcurveTo",
      data: [
        o + k(u[d], a),
        e + k(u[d], a),
        n + k(u[d], a),
        s + k(u[d], a),
        c[0],
        c[1]
      ]
    });
  return l;
}
function X(o) {
  return [...o];
}
function qe(o, e = 0) {
  const n = o.length;
  if (n < 3)
    throw new Error("A curve must have at least three points.");
  const s = [];
  if (n === 3)
    s.push(X(o[0]), X(o[1]), X(o[2]), X(o[2]));
  else {
    const t = [];
    t.push(o[0], o[0]);
    for (let a = 1; a < o.length; a++)
      t.push(o[a]), a === o.length - 1 && t.push(o[a]);
    const r = [], i = 1 - e;
    s.push(X(t[0]));
    for (let a = 1; a + 2 < t.length; a++) {
      const l = t[a];
      r[0] = [l[0], l[1]], r[1] = [l[0] + (i * t[a + 1][0] - i * t[a - 1][0]) / 6, l[1] + (i * t[a + 1][1] - i * t[a - 1][1]) / 6], r[2] = [t[a + 1][0] + (i * t[a][0] - i * t[a + 2][0]) / 6, t[a + 1][1] + (i * t[a][1] - i * t[a + 2][1]) / 6], r[3] = [t[a + 1][0], t[a + 1][1]], s.push(r[1], r[2], r[3]);
    }
  }
  return s;
}
function Lt(o, e) {
  return Math.sqrt(pe(o, e));
}
function pe(o, e) {
  return Math.pow(o[0] - e[0], 2) + Math.pow(o[1] - e[1], 2);
}
function At(o, e, n) {
  const s = pe(e, n);
  if (s === 0)
    return pe(o, e);
  let t = ((o[0] - e[0]) * (n[0] - e[0]) + (o[1] - e[1]) * (n[1] - e[1])) / s;
  return t = Math.max(0, Math.min(1, t)), pe(o, W(e, n, t));
}
function W(o, e, n) {
  return [
    o[0] + (e[0] - o[0]) * n,
    o[1] + (e[1] - o[1]) * n
  ];
}
function jt(o, e) {
  const n = o[e + 0], s = o[e + 1], t = o[e + 2], r = o[e + 3];
  let i = 3 * s[0] - 2 * n[0] - r[0];
  i *= i;
  let a = 3 * s[1] - 2 * n[1] - r[1];
  a *= a;
  let l = 3 * t[0] - 2 * r[0] - n[0];
  l *= l;
  let u = 3 * t[1] - 2 * r[1] - n[1];
  return u *= u, i < l && (i = l), a < u && (a = u), i + a;
}
function Re(o, e, n, s) {
  const t = s || [];
  if (jt(o, e) < n) {
    const r = o[e + 0];
    t.length ? Lt(t[t.length - 1], r) > 1 && t.push(r) : t.push(r), t.push(o[e + 3]);
  } else {
    const i = o[e + 0], a = o[e + 1], l = o[e + 2], u = o[e + 3], c = W(i, a, 0.5), h = W(a, l, 0.5), f = W(l, u, 0.5), d = W(c, h, 0.5), g = W(h, f, 0.5), m = W(d, g, 0.5);
    Re([i, c, d, m], 0, n, t), Re([m, g, f, u], 0, n, t);
  }
  return t;
}
function $t(o, e) {
  return be(o, 0, o.length, e);
}
function be(o, e, n, s, t) {
  const r = t || [], i = o[e], a = o[n - 1];
  let l = 0, u = 1;
  for (let c = e + 1; c < n - 1; ++c) {
    const h = At(o[c], i, a);
    h > l && (l = h, u = c);
  }
  return Math.sqrt(l) > s ? (be(o, e, u + 1, s, r), be(o, u, n, s, r)) : (r.length || r.push(i), r.push(a)), r;
}
function Ce(o, e = 0.15, n) {
  const s = [], t = (o.length - 1) / 3;
  for (let r = 0; r < t; r++) {
    const i = r * 3;
    Re(o, i, e, s);
  }
  return n && n > 0 ? be(s, 0, s.length, n) : s;
}
function Dt(o, e, n) {
  const s = Ae(o), t = Xe(Ze(s)), r = [];
  let i = [], a = [0, 0], l = [];
  const u = () => {
    l.length >= 4 && i.push(...Ce(l, e)), l = [];
  }, c = () => {
    u(), i.length && (r.push(i), i = []);
  };
  for (const { key: f, data: d } of t)
    switch (f) {
      case "M":
        c(), a = [d[0], d[1]], i.push(a);
        break;
      case "L":
        u(), i.push([d[0], d[1]]);
        break;
      case "C":
        if (!l.length) {
          const g = i.length ? i[i.length - 1] : a;
          l.push([g[0], g[1]]);
        }
        l.push([d[0], d[1]]), l.push([d[2], d[3]]), l.push([d[4], d[5]]);
        break;
      case "Z":
        u(), i.push([a[0], a[1]]);
        break;
    }
  if (c(), !n)
    return r;
  const h = [];
  for (const f of r) {
    const d = $t(f, n);
    d.length && h.push(d);
  }
  return h;
}
const R = "none";
class ve {
  constructor(e) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: !1,
      disableMultiStrokeFill: !1,
      preserveVertices: !1,
      fillShapeRoughnessGain: 0.8
    }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return bt();
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, n, s) {
    return { shape: e, sets: n || [], options: s || this.defaultOptions };
  }
  line(e, n, s, t, r) {
    const i = this._o(r);
    return this._d("line", [Qe(e, n, s, t, i)], i);
  }
  rectangle(e, n, s, t, r) {
    const i = this._o(r), a = [], l = Pt(e, n, s, t, i);
    if (i.fill) {
      const u = [[e, n], [e + s, n], [e + s, n + t], [e, n + t]];
      i.fillStyle === "solid" ? a.push(Se([u], i)) : a.push(q([u], i));
    }
    return i.stroke !== R && a.push(l), this._d("rectangle", a, i);
  }
  ellipse(e, n, s, t, r) {
    const i = this._o(r), a = [], l = Je(s, t, i), u = Oe(e, n, i, l);
    if (i.fill)
      if (i.fillStyle === "solid") {
        const c = Oe(e, n, i, l).opset;
        c.type = "fillPath", a.push(c);
      } else
        a.push(q([u.estimatedPoints], i));
    return i.stroke !== R && a.push(u.opset), this._d("ellipse", a, i);
  }
  circle(e, n, s, t) {
    const r = this.ellipse(e, n, s, s, t);
    return r.shape = "circle", r;
  }
  linearPath(e, n) {
    const s = this._o(n);
    return this._d("linearPath", [de(e, !1, s)], s);
  }
  arc(e, n, s, t, r, i, a = !1, l) {
    const u = this._o(l), c = [], h = Ie(e, n, s, t, r, i, a, !0, u);
    if (a && u.fill)
      if (u.fillStyle === "solid") {
        const f = Object.assign({}, u);
        f.disableMultiStroke = !0;
        const d = Ie(e, n, s, t, r, i, !0, !1, f);
        d.type = "fillPath", c.push(d);
      } else
        c.push(xt(e, n, s, t, r, i, u));
    return u.stroke !== R && c.push(h), this._d("arc", c, u);
  }
  curve(e, n) {
    const s = this._o(n), t = [], r = ze(e, s);
    if (s.fill && s.fill !== R)
      if (s.fillStyle === "solid") {
        const i = ze(e, Object.assign(Object.assign({}, s), { disableMultiStroke: !0, roughness: s.roughness ? s.roughness + s.fillShapeRoughnessGain : 0 }));
        t.push({
          type: "fillPath",
          ops: this._mergedShape(i.ops)
        });
      } else {
        const i = [], a = e;
        if (a.length) {
          const u = typeof a[0][0] == "number" ? [a] : a;
          for (const c of u)
            c.length < 3 ? i.push(...c) : c.length === 3 ? i.push(...Ce(qe([
              c[0],
              c[0],
              c[1],
              c[2]
            ]), 10, (1 + s.roughness) / 2)) : i.push(...Ce(qe(c), 10, (1 + s.roughness) / 2));
        }
        i.length && t.push(q([i], s));
      }
    return s.stroke !== R && t.push(r), this._d("curve", t, s);
  }
  polygon(e, n) {
    const s = this._o(n), t = [], r = de(e, !0, s);
    return s.fill && (s.fillStyle === "solid" ? t.push(Se([e], s)) : t.push(q([e], s))), s.stroke !== R && t.push(r), this._d("polygon", t, s);
  }
  path(e, n) {
    const s = this._o(n), t = [];
    if (!e)
      return this._d("path", t, s);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const r = s.fill && s.fill !== "transparent" && s.fill !== R, i = s.stroke !== R, a = !!(s.simplification && s.simplification < 1), l = a ? 4 - 4 * (s.simplification || 1) : (1 + s.roughness) / 2, u = Dt(e, 1, l), c = Ne(e, s);
    if (r)
      if (s.fillStyle === "solid")
        if (u.length === 1) {
          const h = Ne(e, Object.assign(Object.assign({}, s), { disableMultiStroke: !0, roughness: s.roughness ? s.roughness + s.fillShapeRoughnessGain : 0 }));
          t.push({
            type: "fillPath",
            ops: this._mergedShape(h.ops)
          });
        } else
          t.push(Se(u, s));
      else
        t.push(q(u, s));
    return i && (a ? u.forEach((h) => {
      t.push(de(h, !1, s));
    }) : t.push(c)), this._d("path", t, s);
  }
  opsToPath(e, n) {
    let s = "";
    for (const t of e.ops) {
      const r = typeof n == "number" && n >= 0 ? t.data.map((i) => +i.toFixed(n)) : t.data;
      switch (t.op) {
        case "move":
          s += `M${r[0]} ${r[1]} `;
          break;
        case "bcurveTo":
          s += `C${r[0]} ${r[1]}, ${r[2]} ${r[3]}, ${r[4]} ${r[5]} `;
          break;
        case "lineTo":
          s += `L${r[0]} ${r[1]} `;
          break;
      }
    }
    return s.trim();
  }
  toPaths(e) {
    const n = e.sets || [], s = e.options || this.defaultOptions, t = [];
    for (const r of n) {
      let i = null;
      switch (r.type) {
        case "path":
          i = {
            d: this.opsToPath(r),
            stroke: s.stroke,
            strokeWidth: s.strokeWidth,
            fill: R
          };
          break;
        case "fillPath":
          i = {
            d: this.opsToPath(r),
            stroke: R,
            strokeWidth: 0,
            fill: s.fill || R
          };
          break;
        case "fillSketch":
          i = this.fillSketch(r, s);
          break;
      }
      i && t.push(i);
    }
    return t;
  }
  fillSketch(e, n) {
    let s = n.fillWeight;
    return s < 0 && (s = n.strokeWidth / 2), {
      d: this.opsToPath(e),
      stroke: n.fill || R,
      strokeWidth: s,
      fill: R
    };
  }
  _mergedShape(e) {
    return e.filter((n, s) => s === 0 ? !0 : n.op !== "move");
  }
}
class zt {
  constructor(e, n) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new ve(n);
  }
  draw(e) {
    const n = e.sets || [], s = e.options || this.getDefaultOptions(), t = this.ctx, r = e.options.fixedDecimalPlaceDigits;
    for (const i of n)
      switch (i.type) {
        case "path":
          t.save(), t.strokeStyle = s.stroke === "none" ? "transparent" : s.stroke, t.lineWidth = s.strokeWidth, s.strokeLineDash && t.setLineDash(s.strokeLineDash), s.strokeLineDashOffset && (t.lineDashOffset = s.strokeLineDashOffset), this._drawToContext(t, i, r), t.restore();
          break;
        case "fillPath": {
          t.save(), t.fillStyle = s.fill || "";
          const a = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(t, i, r, a), t.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(t, i, s);
          break;
      }
  }
  fillSketch(e, n, s) {
    let t = s.fillWeight;
    t < 0 && (t = s.strokeWidth / 2), e.save(), s.fillLineDash && e.setLineDash(s.fillLineDash), s.fillLineDashOffset && (e.lineDashOffset = s.fillLineDashOffset), e.strokeStyle = s.fill || "", e.lineWidth = t, this._drawToContext(e, n, s.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, n, s, t = "nonzero") {
    e.beginPath();
    for (const r of n.ops) {
      const i = typeof s == "number" && s >= 0 ? r.data.map((a) => +a.toFixed(s)) : r.data;
      switch (r.op) {
        case "move":
          e.moveTo(i[0], i[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
          break;
        case "lineTo":
          e.lineTo(i[0], i[1]);
          break;
      }
    }
    n.type === "fillPath" ? e.fill(t) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, n, s, t, r) {
    const i = this.gen.line(e, n, s, t, r);
    return this.draw(i), i;
  }
  rectangle(e, n, s, t, r) {
    const i = this.gen.rectangle(e, n, s, t, r);
    return this.draw(i), i;
  }
  ellipse(e, n, s, t, r) {
    const i = this.gen.ellipse(e, n, s, t, r);
    return this.draw(i), i;
  }
  circle(e, n, s, t) {
    const r = this.gen.circle(e, n, s, t);
    return this.draw(r), r;
  }
  linearPath(e, n) {
    const s = this.gen.linearPath(e, n);
    return this.draw(s), s;
  }
  polygon(e, n) {
    const s = this.gen.polygon(e, n);
    return this.draw(s), s;
  }
  arc(e, n, s, t, r, i, a = !1, l) {
    const u = this.gen.arc(e, n, s, t, r, i, a, l);
    return this.draw(u), u;
  }
  curve(e, n) {
    const s = this.gen.curve(e, n);
    return this.draw(s), s;
  }
  path(e, n) {
    const s = this.gen.path(e, n);
    return this.draw(s), s;
  }
}
const he = "http://www.w3.org/2000/svg";
class It {
  constructor(e, n) {
    this.svg = e, this.gen = new ve(n);
  }
  draw(e) {
    const n = e.sets || [], s = e.options || this.getDefaultOptions(), t = this.svg.ownerDocument || window.document, r = t.createElementNS(he, "g"), i = e.options.fixedDecimalPlaceDigits;
    for (const a of n) {
      let l = null;
      switch (a.type) {
        case "path": {
          l = t.createElementNS(he, "path"), l.setAttribute("d", this.opsToPath(a, i)), l.setAttribute("stroke", s.stroke), l.setAttribute("stroke-width", s.strokeWidth + ""), l.setAttribute("fill", "none"), s.strokeLineDash && l.setAttribute("stroke-dasharray", s.strokeLineDash.join(" ").trim()), s.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${s.strokeLineDashOffset}`);
          break;
        }
        case "fillPath": {
          l = t.createElementNS(he, "path"), l.setAttribute("d", this.opsToPath(a, i)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", s.fill || ""), (e.shape === "curve" || e.shape === "polygon") && l.setAttribute("fill-rule", "evenodd");
          break;
        }
        case "fillSketch": {
          l = this.fillSketch(t, a, s);
          break;
        }
      }
      l && r.appendChild(l);
    }
    return r;
  }
  fillSketch(e, n, s) {
    let t = s.fillWeight;
    t < 0 && (t = s.strokeWidth / 2);
    const r = e.createElementNS(he, "path");
    return r.setAttribute("d", this.opsToPath(n, s.fixedDecimalPlaceDigits)), r.setAttribute("stroke", s.fill || ""), r.setAttribute("stroke-width", t + ""), r.setAttribute("fill", "none"), s.fillLineDash && r.setAttribute("stroke-dasharray", s.fillLineDash.join(" ").trim()), s.fillLineDashOffset && r.setAttribute("stroke-dashoffset", `${s.fillLineDashOffset}`), r;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, n) {
    return this.gen.opsToPath(e, n);
  }
  line(e, n, s, t, r) {
    const i = this.gen.line(e, n, s, t, r);
    return this.draw(i);
  }
  rectangle(e, n, s, t, r) {
    const i = this.gen.rectangle(e, n, s, t, r);
    return this.draw(i);
  }
  ellipse(e, n, s, t, r) {
    const i = this.gen.ellipse(e, n, s, t, r);
    return this.draw(i);
  }
  circle(e, n, s, t) {
    const r = this.gen.circle(e, n, s, t);
    return this.draw(r);
  }
  linearPath(e, n) {
    const s = this.gen.linearPath(e, n);
    return this.draw(s);
  }
  polygon(e, n) {
    const s = this.gen.polygon(e, n);
    return this.draw(s);
  }
  arc(e, n, s, t, r, i, a = !1, l) {
    const u = this.gen.arc(e, n, s, t, r, i, a, l);
    return this.draw(u);
  }
  curve(e, n) {
    const s = this.gen.curve(e, n);
    return this.draw(s);
  }
  path(e, n) {
    const s = this.gen.path(e, n);
    return this.draw(s);
  }
}
const L = {
  canvas(o, e) {
    return new zt(o, e);
  },
  svg(o, e) {
    return new It(o, e);
  },
  generator(o) {
    return new ve(o);
  },
  newSeed() {
    return ve.newSeed();
  }
}, J = (o, e, n, s, t) => `M${o + t},${e} 
          H${o + n - t} 
          A${t},${t} 0 0 1 ${o + n},${e + t} 
          V${e + s - t} 
          A${t},${t} 0 0 1 ${o + n - t},${e + s} 
          H${o + t} 
          A${t},${t} 0 0 1 ${o},${e + s - t} 
          V${e + t} 
          A${t},${t} 0 0 1 ${o + t},${e} 
          Z`, Nt = {
  "drawui-button": "_drawui-button_1nx7z_1"
}, ge = {
  stroke: {
    thin: {
      color: "#333",
      width: 1.5
    },
    medium: {
      color: "#333",
      width: 2.5
    },
    thick: {
      color: "#333",
      width: 4
    }
  },
  roughness: {
    roughness: 1.8,
    bowing: 2
  },
  fill: {
    background: "#ccccccff"
  },
  radius: {
    none: 0,
    sm: 6,
    md: 10,
    lg: 16,
    full: 30
  },
  buttonSize: {
    sm: {
      width: 100,
      height: 40,
      fontSize: 12
    },
    md: {
      width: 130,
      height: 50,
      fontSize: 15
    },
    lg: {
      width: 150,
      height: 60,
      fontSize: 18
    },
    xl: {
      width: 170,
      height: 70,
      fontSize: 20
    }
  },
  inputSize: {
    sm: {
      height: 32,
      fontSize: 12,
      paddingX: 8
    },
    md: {
      height: 40,
      fontSize: 14,
      paddingX: 12
    },
    lg: {
      height: 48,
      fontSize: 16,
      paddingX: 16
    },
    xl: {
      height: 48,
      fontSize: 16,
      paddingX: 16
    }
  }
}, et = nt(ge), Gt = ({ theme: o, children: e }) => {
  const n = {
    ...ge,
    ...o,
    stroke: {
      ...ge.stroke,
      ...o?.stroke
    },
    radius: {
      ...ge.radius,
      ...o?.radius
    }
  };
  return /* @__PURE__ */ w.jsx(et.Provider, { value: n, children: e });
}, A = () => rt(et), Vt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  size: n = "sm",
  backgroundColor: s,
  children: t,
  ...r
}) => {
  const i = A(), a = E(null), [l, u] = U(!1), c = i.buttonSize[n].width, h = i.buttonSize[n].height, f = i.buttonSize[n].fontSize;
  return C(() => {
    if (!a.current) return;
    const d = L.svg(a.current);
    a.current.innerHTML = "";
    const g = i.stroke[o], m = d.path(
      J(0, 0, c, h, i.radius[e]),
      {
        stroke: g.color,
        strokeWidth: g.width,
        fill: s ?? i.fill.background,
        roughness: l ? i.roughness.roughness + 1 : i.roughness.roughness,
        bowing: i.roughness.bowing
      }
    );
    a.current.appendChild(m);
  }, [l, o, e, i]), /* @__PURE__ */ w.jsxs(
    "button",
    {
      ...r,
      onMouseEnter: () => u(!0),
      onMouseLeave: () => u(!1),
      className: `${Nt["drawui-button"]} ${r.className ?? ""}`,
      style: {
        position: "relative",
        width: c,
        height: h,
        border: "none",
        background: "transparent",
        cursor: "pointer"
      },
      children: [
        /* @__PURE__ */ w.jsx(
          "svg",
          {
            ref: a,
            width: c,
            height: h,
            style: { position: "absolute", inset: 0 }
          }
        ),
        /* @__PURE__ */ w.jsx(
          "span",
          {
            style: {
              position: "relative",
              fontSize: f,
              pointerEvents: "none"
            },
            children: t
          }
        )
      ]
    }
  );
}, fe = {
  "drawui-card": "_drawui-card_vhoat_1",
  "drawui-card-header": "_drawui-card-header_vhoat_7",
  "drawui-card-body": "_drawui-card-body_vhoat_12",
  "drawui-card-footer": "_drawui-card-footer_vhoat_17"
}, Wt = "_vertical_1tdom_6", Ft = "_horizontal_1tdom_11", Pe = {
  "drawui-divider": "_drawui-divider_1tdom_1",
  vertical: Wt,
  horizontal: Ft
}, Ge = ({
  strokeWeight: o = "medium",
  width: e = "100%",
  vertical: n = !1,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    r.current.innerHTML = "";
    const i = L.svg(r.current), a = t.stroke[o];
    if (n) {
      const l = typeof e == "number" ? e : 100, u = i.line(0, 0, 0, l, {
        stroke: a.color,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing
      });
      r.current.appendChild(u);
    } else {
      const l = typeof e == "number" ? e : 300, u = i.line(0, 0, l, 0, {
        stroke: a.color,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing
      });
      r.current.appendChild(u);
    }
  }, [t, o, e, n]), /* @__PURE__ */ w.jsx(
    "div",
    {
      className: `${Pe["drawui-divider"]} ${n ? Pe.vertical : Pe.horizontal} ${s ?? ""}`,
      style: { width: n ? void 0 : e },
      children: /* @__PURE__ */ w.jsx(
        "svg",
        {
          ref: r,
          width: n ? 2 : e,
          height: n ? e : 2,
          style: { display: "block" }
        }
      )
    }
  );
}, Yt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  width: n = 300,
  height: s = 200,
  backgroundColor: t,
  header: r,
  footer: i,
  children: a,
  ...l
}) => {
  const u = A(), c = E(null), [h, f] = U(!1);
  return C(() => {
    if (!c.current) return;
    const d = L.svg(c.current);
    c.current.innerHTML = "";
    const g = u.stroke[o], m = d.path(
      J(0, 0, n, s, u.radius[e]),
      {
        stroke: g.color,
        strokeWidth: g.width,
        fill: t ?? u.fill.background,
        roughness: h ? u.roughness.roughness + 1 : u.roughness.roughness,
        bowing: u.roughness.bowing
      }
    );
    c.current.appendChild(m);
  }, [o, e, n, s, t, u]), /* @__PURE__ */ w.jsxs(
    "div",
    {
      ...l,
      className: `${fe["drawui-card"]} ${l.className ?? ""}`,
      onMouseEnter: () => f(!0),
      onMouseLeave: () => f(!1),
      style: {
        position: "relative",
        width: n,
        height: s,
        cursor: "default",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ w.jsx(
          "svg",
          {
            ref: c,
            width: n,
            height: s,
            style: { position: "absolute", inset: 0, pointerEvents: "none" }
          }
        ),
        r && /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
          /* @__PURE__ */ w.jsx(
            "div",
            {
              className: fe["drawui-card-header"],
              style: { position: "relative", zIndex: 1 },
              children: r
            }
          ),
          /* @__PURE__ */ w.jsx(Ge, { width: n, strokeWeight: "thick" })
        ] }),
        /* @__PURE__ */ w.jsx(
          "div",
          {
            className: fe["drawui-card-body"],
            style: { position: "relative", zIndex: 1, flex: 1 },
            children: a
          }
        ),
        i && /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
          /* @__PURE__ */ w.jsx(Ge, { width: n, strokeWeight: "thick" }),
          /* @__PURE__ */ w.jsx(
            "div",
            {
              className: fe["drawui-card-footer"],
              style: { position: "relative", zIndex: 1 },
              children: i
            }
          )
        ] })
      ]
    }
  );
}, Ve = {
  "drawui-collapse": "_drawui-collapse_mgu8u_1",
  "drawui-collapse-content": "_drawui-collapse-content_mgu8u_22"
}, Bt = ({
  header: o,
  children: e,
  strokeWeight: n = "medium",
  radius: s = "md",
  width: t = 300,
  className: r
}) => {
  const i = A(), a = E(null);
  return C(() => {
    if (!a.current) return;
    const l = L.svg(a.current);
    a.current.innerHTML = "";
    const u = i.stroke[n], c = l.path(
      J(0, 0, t, 40, i.radius[s]),
      {
        stroke: u.color,
        strokeWidth: u.width,
        fill: "transparent",
        roughness: i.roughness.roughness,
        bowing: i.roughness.bowing
      }
    );
    a.current.appendChild(c);
  }, [i, n, s, t]), /* @__PURE__ */ w.jsx("div", { className: `${Ve["drawui-collapse"]} ${r ?? ""}`, style: { width: t }, children: /* @__PURE__ */ w.jsxs("details", { children: [
    /* @__PURE__ */ w.jsxs("summary", { style: { position: "relative" }, children: [
      /* @__PURE__ */ w.jsx(
        "svg",
        {
          ref: a,
          width: t,
          height: 40,
          style: { position: "absolute", inset: 0, pointerEvents: "none" }
        }
      ),
      /* @__PURE__ */ w.jsx("span", { style: { position: "relative", zIndex: 1 }, children: o })
    ] }),
    /* @__PURE__ */ w.jsx("div", { className: Ve["drawui-collapse-content"], children: e })
  ] }) });
}, Ht = {}, Zt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  size: n = "sm",
  icon: s,
  backgroundColor: t,
  ...r
}) => {
  const i = A(), a = E(null), [l, u] = U(!1), c = i.buttonSize[n].height;
  return C(() => {
    if (!a.current) return;
    const h = L.svg(a.current);
    a.current.innerHTML = "";
    const f = i.stroke[o], d = h.path(
      J(0, 0, c, c, i.radius[e]),
      {
        stroke: f.color,
        strokeWidth: f.width,
        fill: t ?? i.fill.background,
        roughness: l ? i.roughness.roughness + 1 : i.roughness.roughness,
        bowing: i.roughness.bowing
      }
    );
    a.current.appendChild(d);
  }, [l, o, e, i, c, t]), /* @__PURE__ */ w.jsxs(
    "button",
    {
      ...r,
      onMouseEnter: () => u(!0),
      onMouseLeave: () => u(!1),
      className: `${Ht["drawui-button"]} ${r.className ?? ""}`,
      style: {
        position: "relative",
        width: c,
        height: c,
        // height and width are equal
        border: "none",
        background: "transparent",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        padding: 0
      },
      children: [
        /* @__PURE__ */ w.jsx(
          "svg",
          {
            ref: a,
            width: c,
            height: c,
            style: {
              position: "absolute",
              inset: 0,
              pointerEvents: "none"
            }
          }
        ),
        /* @__PURE__ */ w.jsx(
          "span",
          {
            style: {
              position: "relative",
              pointerEvents: "none",
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            children: s
          }
        )
      ]
    }
  );
}, Ye = {
  "drawui-input": "_drawui-input_15az9_1",
  "drawui-input-field": "_drawui-input-field_15az9_8"
}, Xt = ({
  strokeWeight: o = "medium",
  backgroundColor: e,
  radius: n = "md",
  inputSize: s = "md",
  className: t,
  style: r,
  ...i
}) => {
  const a = A(), l = E(null), u = E(null), [c, h] = U(!1), [f, d] = U(!1), g = a.inputSize[s].height, m = a.inputSize[s].fontSize, b = a.inputSize[s].paddingX;
  return C(() => {
    if (!l.current || !u.current) return;
    const v = u.current.offsetWidth, y = L.svg(l.current);
    l.current.innerHTML = "";
    const z = a.stroke[o], G = y.path(
      J(0, 0, v, g, a.radius[n]),
      {
        stroke: z.color,
        strokeWidth: z.width,
        fill: e ?? a.fill.background,
        roughness: c ? a.roughness.roughness + 1 : a.roughness.roughness,
        bowing: a.roughness.bowing
      }
    );
    l.current.appendChild(G);
  }, [c, f, o, n, s, a, e]), /* @__PURE__ */ w.jsxs(
    "div",
    {
      ref: u,
      className: `${Ye["drawui-input"]} ${t ?? ""}`,
      style: { height: g, ...r },
      onMouseEnter: () => d(!0),
      onMouseLeave: () => d(!1),
      children: [
        /* @__PURE__ */ w.jsx(
          "svg",
          {
            ref: l,
            width: "100%",
            height: g,
            style: { position: "absolute", inset: 0 }
          }
        ),
        /* @__PURE__ */ w.jsx(
          "input",
          {
            ...i,
            className: Ye["drawui-input-field"],
            style: {
              height: g,
              fontSize: m,
              paddingLeft: b,
              paddingRight: b
            },
            onFocus: (v) => {
              h(!0), i.onFocus?.(v);
            },
            onBlur: (v) => {
              h(!1), i.onBlur?.(v);
            }
          }
        )
      ]
    }
  );
}, Ut = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.path(
      "M6 18 H18 L16 12 A6 6 0 0 0 8 12 Z",
      {
        stroke: l,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(u);
    const c = i.circle(12, 18, 2, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(c);
  }, [t, e, n]), /* @__PURE__ */ w.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: s });
}, Qt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.path(
      "M2 12 L12 2 L22 12 V22 H2 Z",
      {
        stroke: l,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(u);
  }, [t, e, n]), /* @__PURE__ */ w.jsx(
    "svg",
    {
      ref: r,
      width: o,
      height: o,
      viewBox: "0 0 24 24",
      className: s
    }
  );
}, Jt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.line(4, 12, 20, 12, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing
    });
    r.current.appendChild(u);
  }, [t, e, n]), /* @__PURE__ */ w.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: s });
}, Kt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.line(12, 4, 12, 20, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing
    }), c = i.line(4, 12, 20, 12, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing
    });
    r.current.appendChild(u), r.current.appendChild(c);
  }, [t, e, n]), /* @__PURE__ */ w.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: s });
}, es = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.circle(10, 10, 14, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing,
      fill: "transparent"
    }), c = i.line(16, 16, 22, 22, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing
    });
    r.current.appendChild(u), r.current.appendChild(c);
  }, [t, e, n]), /* @__PURE__ */ w.jsx(
    "svg",
    {
      ref: r,
      width: o,
      height: o,
      viewBox: "0 0 24 24",
      className: s
    }
  );
}, ts = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.circle(12, 12, 14, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(u);
    for (let c = 0; c < 8; c++) {
      const h = c * Math.PI * 2 / 8, f = 12 + 7 * Math.cos(h), d = 12 + 7 * Math.sin(h), g = 12 + 10 * Math.cos(h), m = 12 + 10 * Math.sin(h), b = i.line(f, d, g, m, {
        stroke: l,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing
      });
      r.current.appendChild(b);
    }
  }, [t, e, n]), /* @__PURE__ */ w.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: s });
}, ss = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: n,
  className: s
}) => {
  const t = A(), r = E(null);
  return C(() => {
    if (!r.current) return;
    const i = L.svg(r.current);
    r.current.innerHTML = "";
    const a = t.stroke[e], l = n ?? a.color, u = i.circle(12, 8, 6, {
      stroke: l,
      strokeWidth: a.width,
      roughness: t.roughness.roughness,
      bowing: t.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(u);
    const c = i.path(
      "M4 20 Q12 16 20 20",
      {
        stroke: l,
        strokeWidth: a.width,
        roughness: t.roughness.roughness,
        bowing: t.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(c);
  }, [t, e, n]), /* @__PURE__ */ w.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: s });
};
export {
  Vt as DrawuiButton,
  Yt as DrawuiCard,
  Bt as DrawuiCollapse,
  Ge as DrawuiDivider,
  Zt as DrawuiIconButton,
  Xt as DrawuiInput,
  Gt as DrawuiThemeProvider,
  Ut as IconBell,
  Qt as IconHome,
  Jt as IconMinus,
  Kt as IconPlus,
  es as IconSearch,
  ts as IconSettings,
  ss as IconUser,
  A as useDrawuiTheme
};
