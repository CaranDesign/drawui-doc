import st, { createContext as nt, useContext as rt, useRef as O, useState as Y, useEffect as R } from "react";
var ce = { exports: {} }, Z = {};
var je;
function ot() {
  if (je) return Z;
  je = 1;
  var o = /* @__PURE__ */ Symbol.for("react.transitional.element"), e = /* @__PURE__ */ Symbol.for("react.fragment");
  function s(t, n, r) {
    var i = null;
    if (r !== void 0 && (i = "" + r), n.key !== void 0 && (i = "" + n.key), "key" in n) {
      r = {};
      for (var a in n)
        a !== "key" && (r[a] = n[a]);
    } else r = n;
    return n = r.ref, {
      $$typeof: o,
      type: t,
      key: i,
      ref: n !== void 0 ? n : null,
      props: r
    };
  }
  return Z.Fragment = e, Z.jsx = s, Z.jsxs = s, Z;
}
var X = {};
var $e;
function at() {
  return $e || ($e = 1, process.env.NODE_ENV !== "production" && (function() {
    function o(p) {
      if (p == null) return null;
      if (typeof p == "function")
        return p.$$typeof === re ? null : p.displayName || p.name || null;
      if (typeof p == "string") return p;
      switch (p) {
        case b:
          return "Fragment";
        case y:
          return "Profiler";
        case v:
          return "StrictMode";
        case ee:
          return "Suspense";
        case te:
          return "SuspenseList";
        case ne:
          return "Activity";
      }
      if (typeof p == "object")
        switch (typeof p.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), p.$$typeof) {
          case m:
            return "Portal";
          case z:
            return p.displayName || "Context";
          case C:
            return (p._context.displayName || "Context") + ".Consumer";
          case N:
            var w = p.render;
            return p = p.displayName, p || (p = w.displayName || w.name || "", p = p !== "" ? "ForwardRef(" + p + ")" : "ForwardRef"), p;
          case se:
            return w = p.displayName || null, w !== null ? w : o(p.type) || "Memo";
          case D:
            w = p._payload, p = p._init;
            try {
              return o(p(w));
            } catch {
            }
        }
      return null;
    }
    function e(p) {
      return "" + p;
    }
    function s(p) {
      try {
        e(p);
        var w = !1;
      } catch {
        w = !0;
      }
      if (w) {
        w = console;
        var _ = w.error, P = typeof Symbol == "function" && Symbol.toStringTag && p[Symbol.toStringTag] || p.constructor.name || "Object";
        return _.call(
          w,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          P
        ), e(p);
      }
    }
    function t(p) {
      if (p === b) return "<>";
      if (typeof p == "object" && p !== null && p.$$typeof === D)
        return "<...>";
      try {
        var w = o(p);
        return w ? "<" + w + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function n() {
      var p = x.A;
      return p === null ? null : p.getOwner();
    }
    function r() {
      return Error("react-stack-top-frame");
    }
    function i(p) {
      if (S.call(p, "key")) {
        var w = Object.getOwnPropertyDescriptor(p, "key").get;
        if (w && w.isReactWarning) return !1;
      }
      return p.key !== void 0;
    }
    function a(p, w) {
      function _() {
        I || (I = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          w
        ));
      }
      _.isReactWarning = !0, Object.defineProperty(p, "key", {
        get: _,
        configurable: !0
      });
    }
    function c() {
      var p = o(this.type);
      return q[p] || (q[p] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), p = this.props.ref, p !== void 0 ? p : null;
    }
    function u(p, w, _, P, ie, Me) {
      var T = _.ref;
      return p = {
        $$typeof: g,
        type: p,
        key: w,
        props: _,
        _owner: P
      }, (T !== void 0 ? T : null) !== null ? Object.defineProperty(p, "ref", {
        enumerable: !1,
        get: c
      }) : Object.defineProperty(p, "ref", { enumerable: !1, value: null }), p._store = {}, Object.defineProperty(p._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(p, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(p, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ie
      }), Object.defineProperty(p, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Me
      }), Object.freeze && (Object.freeze(p.props), Object.freeze(p)), p;
    }
    function l(p, w, _, P, ie, Me) {
      var T = w.children;
      if (T !== void 0)
        if (P)
          if ($(T)) {
            for (P = 0; P < T.length; P++)
              h(T[P]);
            Object.freeze && Object.freeze(T);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else h(T);
      if (S.call(w, "key")) {
        T = o(p);
        var G = Object.keys(w).filter(function(tt) {
          return tt !== "key";
        });
        P = 0 < G.length ? "{key: someKey, " + G.join(": ..., ") + ": ...}" : "{key: someKey}", B[T + P] || (G = 0 < G.length ? "{" + G.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          P,
          T,
          G,
          T
        ), B[T + P] = !0);
      }
      if (T = null, _ !== void 0 && (s(_), T = "" + _), i(w) && (s(w.key), T = "" + w.key), "key" in w) {
        _ = {};
        for (var ye in w)
          ye !== "key" && (_[ye] = w[ye]);
      } else _ = w;
      return T && a(
        _,
        typeof p == "function" ? p.displayName || p.name || "Unknown" : p
      ), u(
        p,
        T,
        _,
        n(),
        ie,
        Me
      );
    }
    function h(p) {
      f(p) ? p._store && (p._store.validated = 1) : typeof p == "object" && p !== null && p.$$typeof === D && (p._payload.status === "fulfilled" ? f(p._payload.value) && p._payload.value._store && (p._payload.value._store.validated = 1) : p._store && (p._store.validated = 1));
    }
    function f(p) {
      return typeof p == "object" && p !== null && p.$$typeof === g;
    }
    var d = st, g = /* @__PURE__ */ Symbol.for("react.transitional.element"), m = /* @__PURE__ */ Symbol.for("react.portal"), b = /* @__PURE__ */ Symbol.for("react.fragment"), v = /* @__PURE__ */ Symbol.for("react.strict_mode"), y = /* @__PURE__ */ Symbol.for("react.profiler"), C = /* @__PURE__ */ Symbol.for("react.consumer"), z = /* @__PURE__ */ Symbol.for("react.context"), N = /* @__PURE__ */ Symbol.for("react.forward_ref"), ee = /* @__PURE__ */ Symbol.for("react.suspense"), te = /* @__PURE__ */ Symbol.for("react.suspense_list"), se = /* @__PURE__ */ Symbol.for("react.memo"), D = /* @__PURE__ */ Symbol.for("react.lazy"), ne = /* @__PURE__ */ Symbol.for("react.activity"), re = /* @__PURE__ */ Symbol.for("react.client.reference"), x = d.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, S = Object.prototype.hasOwnProperty, $ = Array.isArray, W = console.createTask ? console.createTask : function() {
      return null;
    };
    d = {
      react_stack_bottom_frame: function(p) {
        return p();
      }
    };
    var I, q = {}, oe = d.react_stack_bottom_frame.bind(
      d,
      r
    )(), ae = W(t(r)), B = {};
    X.Fragment = b, X.jsx = function(p, w, _) {
      var P = 1e4 > x.recentlyCreatedOwnerStacks++;
      return l(
        p,
        w,
        _,
        !1,
        P ? Error("react-stack-top-frame") : oe,
        P ? W(t(p)) : ae
      );
    }, X.jsxs = function(p, w, _) {
      var P = 1e4 > x.recentlyCreatedOwnerStacks++;
      return l(
        p,
        w,
        _,
        !0,
        P ? Error("react-stack-top-frame") : oe,
        P ? W(t(p)) : ae
      );
    };
  })()), X;
}
var ze;
function it() {
  return ze || (ze = 1, process.env.NODE_ENV === "production" ? ce.exports = ot() : ce.exports = at()), ce.exports;
}
var M = it();
function Te(o, e, s) {
  if (o && o.length) {
    const [t, n] = e, r = Math.PI / 180 * s, i = Math.cos(r), a = Math.sin(r);
    for (const c of o) {
      const [u, l] = c;
      c[0] = (u - t) * i - (l - n) * a + t, c[1] = (u - t) * a + (l - n) * i + n;
    }
  }
}
function ct(o, e, s) {
  const t = [];
  o.forEach((n) => t.push(...n)), Te(t, e, s);
}
function lt(o, e) {
  return o[0] === e[0] && o[1] === e[1];
}
function ut(o, e, s, t = 1) {
  const n = s, r = Math.max(e, 0.1), i = o[0] && o[0][0] && typeof o[0][0] == "number" ? [o] : o, a = [0, 0];
  if (n)
    for (const u of i)
      Te(u, a, n);
  const c = ht(i, r, t);
  if (n) {
    for (const u of i)
      Te(u, a, -n);
    ct(c, a, -n);
  }
  return c;
}
function ht(o, e, s) {
  const t = [];
  for (const u of o) {
    const l = [...u];
    lt(l[0], l[l.length - 1]) || l.push([l[0][0], l[0][1]]), l.length > 2 && t.push(l);
  }
  const n = [];
  e = Math.max(e, 0.1);
  const r = [];
  for (const u of t)
    for (let l = 0; l < u.length - 1; l++) {
      const h = u[l], f = u[l + 1];
      if (h[1] !== f[1]) {
        const d = Math.min(h[1], f[1]);
        r.push({
          ymin: d,
          ymax: Math.max(h[1], f[1]),
          x: d === h[1] ? h[0] : f[0],
          islope: (f[0] - h[0]) / (f[1] - h[1])
        });
      }
    }
  if (r.sort((u, l) => u.ymin < l.ymin ? -1 : u.ymin > l.ymin ? 1 : u.x < l.x ? -1 : u.x > l.x ? 1 : u.ymax === l.ymax ? 0 : (u.ymax - l.ymax) / Math.abs(u.ymax - l.ymax)), !r.length)
    return n;
  let i = [], a = r[0].ymin, c = 0;
  for (; i.length || r.length; ) {
    if (r.length) {
      let u = -1;
      for (let h = 0; h < r.length && !(r[h].ymin > a); h++)
        u = h;
      r.splice(0, u + 1).forEach((h) => {
        i.push({ s: a, edge: h });
      });
    }
    if (i = i.filter((u) => !(u.edge.ymax <= a)), i.sort((u, l) => u.edge.x === l.edge.x ? 0 : (u.edge.x - l.edge.x) / Math.abs(u.edge.x - l.edge.x)), (s !== 1 || c % e === 0) && i.length > 1)
      for (let u = 0; u < i.length; u = u + 2) {
        const l = u + 1;
        if (l >= i.length)
          break;
        const h = i[u].edge, f = i[l].edge;
        n.push([
          [Math.round(h.x), a],
          [Math.round(f.x), a]
        ]);
      }
    a += s, i.forEach((u) => {
      u.edge.x = u.edge.x + s * u.edge.islope;
    }), c++;
  }
  return n;
}
function J(o, e) {
  var s;
  const t = e.hachureAngle + 90;
  let n = e.hachureGap;
  n < 0 && (n = e.strokeWidth * 4), n = Math.round(Math.max(n, 0.1));
  let r = 1;
  return e.roughness >= 1 && (((s = e.randomizer) === null || s === void 0 ? void 0 : s.next()) || Math.random()) > 0.7 && (r = n), ut(o, n, t, r || 1);
}
class Le {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, s) {
    return this._fillPolygons(e, s);
  }
  _fillPolygons(e, s) {
    const t = J(e, s);
    return { type: "fillSketch", ops: this.renderLines(t, s) };
  }
  renderLines(e, s) {
    const t = [];
    for (const n of e)
      t.push(...this.helper.doubleLineOps(n[0][0], n[0][1], n[1][0], n[1][1], s));
    return t;
  }
}
function we(o) {
  const e = o[0], s = o[1];
  return Math.sqrt(Math.pow(e[0] - s[0], 2) + Math.pow(e[1] - s[1], 2));
}
class ft extends Le {
  fillPolygons(e, s) {
    let t = s.hachureGap;
    t < 0 && (t = s.strokeWidth * 4), t = Math.max(t, 0.1);
    const n = Object.assign({}, s, { hachureGap: t }), r = J(e, n), i = Math.PI / 180 * s.hachureAngle, a = [], c = t * 0.5 * Math.cos(i), u = t * 0.5 * Math.sin(i);
    for (const [h, f] of r)
      we([h, f]) && a.push([
        [h[0] - c, h[1] + u],
        [...f]
      ], [
        [h[0] + c, h[1] - u],
        [...f]
      ]);
    return { type: "fillSketch", ops: this.renderLines(a, s) };
  }
}
class dt extends Le {
  fillPolygons(e, s) {
    const t = this._fillPolygons(e, s), n = Object.assign({}, s, { hachureAngle: s.hachureAngle + 90 }), r = this._fillPolygons(e, n);
    return t.ops = t.ops.concat(r.ops), t;
  }
}
class pt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, s) {
    s = Object.assign({}, s, { hachureAngle: 0 });
    const t = J(e, s);
    return this.dotsOnLines(t, s);
  }
  dotsOnLines(e, s) {
    const t = [];
    let n = s.hachureGap;
    n < 0 && (n = s.strokeWidth * 4), n = Math.max(n, 0.1);
    let r = s.fillWeight;
    r < 0 && (r = s.strokeWidth / 2);
    const i = n / 4;
    for (const a of e) {
      const c = we(a), u = c / n, l = Math.ceil(u) - 1, h = c - l * n, f = (a[0][0] + a[1][0]) / 2 - n / 4, d = Math.min(a[0][1], a[1][1]);
      for (let g = 0; g < l; g++) {
        const m = d + h + g * n, b = f - i + Math.random() * 2 * i, v = m - i + Math.random() * 2 * i, y = this.helper.ellipse(b, v, r, r, s);
        t.push(...y.ops);
      }
    }
    return { type: "fillSketch", ops: t };
  }
}
class gt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, s) {
    const t = J(e, s);
    return { type: "fillSketch", ops: this.dashedLine(t, s) };
  }
  dashedLine(e, s) {
    const t = s.dashOffset < 0 ? s.hachureGap < 0 ? s.strokeWidth * 4 : s.hachureGap : s.dashOffset, n = s.dashGap < 0 ? s.hachureGap < 0 ? s.strokeWidth * 4 : s.hachureGap : s.dashGap, r = [];
    return e.forEach((i) => {
      const a = we(i), c = Math.floor(a / (t + n)), u = (a + n - c * (t + n)) / 2;
      let l = i[0], h = i[1];
      l[0] > h[0] && (l = i[1], h = i[0]);
      const f = Math.atan((h[1] - l[1]) / (h[0] - l[0]));
      for (let d = 0; d < c; d++) {
        const g = d * (t + n), m = g + t, b = [l[0] + g * Math.cos(f) + u * Math.cos(f), l[1] + g * Math.sin(f) + u * Math.sin(f)], v = [l[0] + m * Math.cos(f) + u * Math.cos(f), l[1] + m * Math.sin(f) + u * Math.sin(f)];
        r.push(...this.helper.doubleLineOps(b[0], b[1], v[0], v[1], s));
      }
    }), r;
  }
}
class mt {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, s) {
    const t = s.hachureGap < 0 ? s.strokeWidth * 4 : s.hachureGap, n = s.zigzagOffset < 0 ? t : s.zigzagOffset;
    s = Object.assign({}, s, { hachureGap: t + n });
    const r = J(e, s);
    return { type: "fillSketch", ops: this.zigzagLines(r, n, s) };
  }
  zigzagLines(e, s, t) {
    const n = [];
    return e.forEach((r) => {
      const i = we(r), a = Math.round(i / (2 * s));
      let c = r[0], u = r[1];
      c[0] > u[0] && (c = r[1], u = r[0]);
      const l = Math.atan((u[1] - c[1]) / (u[0] - c[0]));
      for (let h = 0; h < a; h++) {
        const f = h * 2 * s, d = (h + 1) * 2 * s, g = Math.sqrt(2 * Math.pow(s, 2)), m = [c[0] + f * Math.cos(l), c[1] + f * Math.sin(l)], b = [c[0] + d * Math.cos(l), c[1] + d * Math.sin(l)], v = [m[0] + g * Math.cos(l + Math.PI / 4), m[1] + g * Math.sin(l + Math.PI / 4)];
        n.push(...this.helper.doubleLineOps(m[0], m[1], v[0], v[1], t), ...this.helper.doubleLineOps(v[0], v[1], b[0], b[1], t));
      }
    }), n;
  }
}
const E = {};
function kt(o, e) {
  let s = o.fillStyle || "hachure";
  if (!E[s])
    switch (s) {
      case "zigzag":
        E[s] || (E[s] = new ft(e));
        break;
      case "cross-hatch":
        E[s] || (E[s] = new dt(e));
        break;
      case "dots":
        E[s] || (E[s] = new pt(e));
        break;
      case "dashed":
        E[s] || (E[s] = new gt(e));
        break;
      case "zigzag-line":
        E[s] || (E[s] = new mt(e));
        break;
      default:
        s = "hachure", E[s] || (E[s] = new Le(e));
        break;
    }
  return E[s];
}
function bt() {
  return Math.floor(Math.random() * 2 ** 31);
}
class vt {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
}
const wt = 0, xe = 1, Be = 2, le = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function Mt(o) {
  const e = new Array();
  for (; o !== ""; )
    if (o.match(/^([ \t\r\n,]+)/))
      o = o.substr(RegExp.$1.length);
    else if (o.match(/^([aAcChHlLmMqQsStTvVzZ])/))
      e[e.length] = { type: wt, text: RegExp.$1 }, o = o.substr(RegExp.$1.length);
    else if (o.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))
      e[e.length] = { type: xe, text: `${parseFloat(RegExp.$1)}` }, o = o.substr(RegExp.$1.length);
    else
      return [];
  return e[e.length] = { type: Be, text: "" }, e;
}
function _e(o, e) {
  return o.type === e;
}
function Ae(o) {
  const e = [], s = Mt(o);
  let t = "BOD", n = 0, r = s[n];
  for (; !_e(r, Be); ) {
    let i = 0;
    const a = [];
    if (t === "BOD")
      if (r.text === "M" || r.text === "m")
        n++, i = le[r.text], t = r.text;
      else
        return Ae("M0,0" + o);
    else _e(r, xe) ? i = le[t] : (n++, i = le[r.text], t = r.text);
    if (n + i < s.length) {
      for (let c = n; c < n + i; c++) {
        const u = s[c];
        if (_e(u, xe))
          a[a.length] = +u.text;
        else
          throw new Error("Param not a number: " + t + "," + u.text);
      }
      if (typeof le[t] == "number") {
        const c = { key: t, data: a };
        e.push(c), n += i, r = s[n], t === "M" && (t = "L"), t === "m" && (t = "l");
      } else
        throw new Error("Bad segment: " + t);
    } else
      throw new Error("Path data ended short");
  }
  return e;
}
function Ze(o) {
  let e = 0, s = 0, t = 0, n = 0;
  const r = [];
  for (const { key: i, data: a } of o)
    switch (i) {
      case "M":
        r.push({ key: "M", data: [...a] }), [e, s] = a, [t, n] = a;
        break;
      case "m":
        e += a[0], s += a[1], r.push({ key: "M", data: [e, s] }), t = e, n = s;
        break;
      case "L":
        r.push({ key: "L", data: [...a] }), [e, s] = a;
        break;
      case "l":
        e += a[0], s += a[1], r.push({ key: "L", data: [e, s] });
        break;
      case "C":
        r.push({ key: "C", data: [...a] }), e = a[4], s = a[5];
        break;
      case "c": {
        const c = a.map((u, l) => l % 2 ? u + s : u + e);
        r.push({ key: "C", data: c }), e = c[4], s = c[5];
        break;
      }
      case "Q":
        r.push({ key: "Q", data: [...a] }), e = a[2], s = a[3];
        break;
      case "q": {
        const c = a.map((u, l) => l % 2 ? u + s : u + e);
        r.push({ key: "Q", data: c }), e = c[2], s = c[3];
        break;
      }
      case "A":
        r.push({ key: "A", data: [...a] }), e = a[5], s = a[6];
        break;
      case "a":
        e += a[5], s += a[6], r.push({ key: "A", data: [a[0], a[1], a[2], a[3], a[4], e, s] });
        break;
      case "H":
        r.push({ key: "H", data: [...a] }), e = a[0];
        break;
      case "h":
        e += a[0], r.push({ key: "H", data: [e] });
        break;
      case "V":
        r.push({ key: "V", data: [...a] }), s = a[0];
        break;
      case "v":
        s += a[0], r.push({ key: "V", data: [s] });
        break;
      case "S":
        r.push({ key: "S", data: [...a] }), e = a[2], s = a[3];
        break;
      case "s": {
        const c = a.map((u, l) => l % 2 ? u + s : u + e);
        r.push({ key: "S", data: c }), e = c[2], s = c[3];
        break;
      }
      case "T":
        r.push({ key: "T", data: [...a] }), e = a[0], s = a[1];
        break;
      case "t":
        e += a[0], s += a[1], r.push({ key: "T", data: [e, s] });
        break;
      case "Z":
      case "z":
        r.push({ key: "Z", data: [] }), e = t, s = n;
        break;
    }
  return r;
}
function Xe(o) {
  const e = [];
  let s = "", t = 0, n = 0, r = 0, i = 0, a = 0, c = 0;
  for (const { key: u, data: l } of o) {
    switch (u) {
      case "M":
        e.push({ key: "M", data: [...l] }), [t, n] = l, [r, i] = l;
        break;
      case "C":
        e.push({ key: "C", data: [...l] }), t = l[4], n = l[5], a = l[2], c = l[3];
        break;
      case "L":
        e.push({ key: "L", data: [...l] }), [t, n] = l;
        break;
      case "H":
        t = l[0], e.push({ key: "L", data: [t, n] });
        break;
      case "V":
        n = l[0], e.push({ key: "L", data: [t, n] });
        break;
      case "S": {
        let h = 0, f = 0;
        s === "C" || s === "S" ? (h = t + (t - a), f = n + (n - c)) : (h = t, f = n), e.push({ key: "C", data: [h, f, ...l] }), a = l[0], c = l[1], t = l[2], n = l[3];
        break;
      }
      case "T": {
        const [h, f] = l;
        let d = 0, g = 0;
        s === "Q" || s === "T" ? (d = t + (t - a), g = n + (n - c)) : (d = t, g = n);
        const m = t + 2 * (d - t) / 3, b = n + 2 * (g - n) / 3, v = h + 2 * (d - h) / 3, y = f + 2 * (g - f) / 3;
        e.push({ key: "C", data: [m, b, v, y, h, f] }), a = d, c = g, t = h, n = f;
        break;
      }
      case "Q": {
        const [h, f, d, g] = l, m = t + 2 * (h - t) / 3, b = n + 2 * (f - n) / 3, v = d + 2 * (h - d) / 3, y = g + 2 * (f - g) / 3;
        e.push({ key: "C", data: [m, b, v, y, d, g] }), a = h, c = f, t = d, n = g;
        break;
      }
      case "A": {
        const h = Math.abs(l[0]), f = Math.abs(l[1]), d = l[2], g = l[3], m = l[4], b = l[5], v = l[6];
        h === 0 || f === 0 ? (e.push({ key: "C", data: [t, n, b, v, b, v] }), t = b, n = v) : (t !== b || n !== v) && (Ue(t, n, b, v, h, f, d, g, m).forEach(function(C) {
          e.push({ key: "C", data: C });
        }), t = b, n = v);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), t = r, n = i;
        break;
    }
    s = u;
  }
  return e;
}
function yt(o) {
  return Math.PI * o / 180;
}
function U(o, e, s) {
  const t = o * Math.cos(s) - e * Math.sin(s), n = o * Math.sin(s) + e * Math.cos(s);
  return [t, n];
}
function Ue(o, e, s, t, n, r, i, a, c, u) {
  const l = yt(i);
  let h = [], f = 0, d = 0, g = 0, m = 0;
  if (u)
    [f, d, g, m] = u;
  else {
    [o, e] = U(o, e, -l), [s, t] = U(s, t, -l);
    const x = (o - s) / 2, S = (e - t) / 2;
    let $ = x * x / (n * n) + S * S / (r * r);
    $ > 1 && ($ = Math.sqrt($), n = $ * n, r = $ * r);
    const W = a === c ? -1 : 1, I = n * n, q = r * r, oe = I * q - I * S * S - q * x * x, ae = I * S * S + q * x * x, B = W * Math.sqrt(Math.abs(oe / ae));
    g = B * n * S / r + (o + s) / 2, m = B * -r * x / n + (e + t) / 2, f = Math.asin(parseFloat(((e - m) / r).toFixed(9))), d = Math.asin(parseFloat(((t - m) / r).toFixed(9))), o < g && (f = Math.PI - f), s < g && (d = Math.PI - d), f < 0 && (f = Math.PI * 2 + f), d < 0 && (d = Math.PI * 2 + d), c && f > d && (f = f - Math.PI * 2), !c && d > f && (d = d - Math.PI * 2);
  }
  let b = d - f;
  if (Math.abs(b) > Math.PI * 120 / 180) {
    const x = d, S = s, $ = t;
    c && d > f ? d = f + Math.PI * 120 / 180 * 1 : d = f + Math.PI * 120 / 180 * -1, s = g + n * Math.cos(d), t = m + r * Math.sin(d), h = Ue(s, t, S, $, n, r, i, 0, c, [d, x, g, m]);
  }
  b = d - f;
  const v = Math.cos(f), y = Math.sin(f), C = Math.cos(d), z = Math.sin(d), N = Math.tan(b / 4), ee = 4 / 3 * n * N, te = 4 / 3 * r * N, se = [o, e], D = [o + ee * y, e - te * v], ne = [s + ee * z, t - te * C], re = [s, t];
  if (D[0] = 2 * se[0] - D[0], D[1] = 2 * se[1] - D[1], u)
    return [D, ne, re].concat(h);
  {
    h = [D, ne, re].concat(h);
    const x = [];
    for (let S = 0; S < h.length; S += 3) {
      const $ = U(h[S][0], h[S][1], l), W = U(h[S + 1][0], h[S + 1][1], l), I = U(h[S + 2][0], h[S + 2][1], l);
      x.push([$[0], $[1], W[0], W[1], I[0], I[1]]);
    }
    return x;
  }
}
const _t = {
  randOffset: Ot,
  randOffsetWithRange: Et,
  ellipse: Tt,
  doubleLineOps: Rt
};
function Qe(o, e, s, t, n) {
  return { type: "path", ops: H(o, e, s, t, n) };
}
function de(o, e, s) {
  const t = (o || []).length;
  if (t > 2) {
    const n = [];
    for (let r = 0; r < t - 1; r++)
      n.push(...H(o[r][0], o[r][1], o[r + 1][0], o[r + 1][1], s));
    return e && n.push(...H(o[t - 1][0], o[t - 1][1], o[0][0], o[0][1], s)), { type: "path", ops: n };
  } else if (t === 2)
    return Qe(o[0][0], o[0][1], o[1][0], o[1][1], s);
  return { type: "path", ops: [] };
}
function St(o, e) {
  return de(o, !0, e);
}
function Pt(o, e, s, t, n) {
  const r = [
    [o, e],
    [o + s, e],
    [o + s, e + t],
    [o, e + t]
  ];
  return St(r, n);
}
function De(o, e) {
  if (o.length) {
    const t = typeof o[0][0] == "number" ? [o] : o, n = ue(t[0], 1 * (1 + e.roughness * 0.2), e), r = e.disableMultiStroke ? [] : ue(t[0], 1.5 * (1 + e.roughness * 0.22), We(e));
    for (let i = 1; i < t.length; i++) {
      const a = t[i];
      if (a.length) {
        const c = ue(a, 1 * (1 + e.roughness * 0.2), e), u = e.disableMultiStroke ? [] : ue(a, 1.5 * (1 + e.roughness * 0.22), We(e));
        for (const l of c)
          l.op !== "move" && n.push(l);
        for (const l of u)
          l.op !== "move" && r.push(l);
      }
    }
    return { type: "path", ops: n.concat(r) };
  }
  return { type: "path", ops: [] };
}
function Tt(o, e, s, t, n) {
  const r = Je(s, t, n);
  return Oe(o, e, n, r).opset;
}
function Je(o, e, s) {
  const t = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(o / 2, 2) + Math.pow(e / 2, 2)) / 2)), n = Math.ceil(Math.max(s.curveStepCount, s.curveStepCount / Math.sqrt(200) * t)), r = Math.PI * 2 / n;
  let i = Math.abs(o / 2), a = Math.abs(e / 2);
  const c = 1 - s.curveFitting;
  return i += k(i * c, s), a += k(a * c, s), { increment: r, rx: i, ry: a };
}
function Oe(o, e, s, t) {
  const [n, r] = He(t.increment, o, e, t.rx, t.ry, 1, t.increment * me(0.1, me(0.4, 1, s), s), s);
  let i = ke(n, null, s);
  if (!s.disableMultiStroke && s.roughness !== 0) {
    const [a] = He(t.increment, o, e, t.rx, t.ry, 1.5, 0, s), c = ke(a, null, s);
    i = i.concat(c);
  }
  return {
    estimatedPoints: r,
    opset: { type: "path", ops: i }
  };
}
function Ie(o, e, s, t, n, r, i, a, c) {
  const u = o, l = e;
  let h = Math.abs(s / 2), f = Math.abs(t / 2);
  h += k(h * 0.01, c), f += k(f * 0.01, c);
  let d = n, g = r;
  for (; d < 0; )
    d += Math.PI * 2, g += Math.PI * 2;
  g - d > Math.PI * 2 && (d = 0, g = Math.PI * 2);
  const m = Math.PI * 2 / c.curveStepCount, b = Math.min(m / 2, (g - d) / 2), v = Fe(b, u, l, h, f, d, g, 1, c);
  if (!c.disableMultiStroke) {
    const y = Fe(b, u, l, h, f, d, g, 1.5, c);
    v.push(...y);
  }
  return i && (a ? v.push(...H(u, l, u + h * Math.cos(d), l + f * Math.sin(d), c), ...H(u, l, u + h * Math.cos(g), l + f * Math.sin(g), c)) : v.push({ op: "lineTo", data: [u, l] }, { op: "lineTo", data: [u + h * Math.cos(d), l + f * Math.sin(d)] })), { type: "path", ops: v };
}
function Ne(o, e) {
  const s = Xe(Ze(Ae(o))), t = [];
  let n = [0, 0], r = [0, 0];
  for (const { key: i, data: a } of s)
    switch (i) {
      case "M": {
        r = [a[0], a[1]], n = [a[0], a[1]];
        break;
      }
      case "L":
        t.push(...H(r[0], r[1], a[0], a[1], e)), r = [a[0], a[1]];
        break;
      case "C": {
        const [c, u, l, h, f, d] = a;
        t.push(...Ct(c, u, l, h, f, d, r, e)), r = [f, d];
        break;
      }
      case "Z":
        t.push(...H(r[0], r[1], n[0], n[1], e)), r = [n[0], n[1]];
        break;
    }
  return { type: "path", ops: t };
}
function Se(o, e) {
  const s = [];
  for (const t of o)
    if (t.length) {
      const n = e.maxRandomnessOffset || 0, r = t.length;
      if (r > 2) {
        s.push({ op: "move", data: [t[0][0] + k(n, e), t[0][1] + k(n, e)] });
        for (let i = 1; i < r; i++)
          s.push({ op: "lineTo", data: [t[i][0] + k(n, e), t[i][1] + k(n, e)] });
      }
    }
  return { type: "fillPath", ops: s };
}
function V(o, e) {
  return kt(e, _t).fillPolygons(o, e);
}
function xt(o, e, s, t, n, r, i) {
  const a = o, c = e;
  let u = Math.abs(s / 2), l = Math.abs(t / 2);
  u += k(u * 0.01, i), l += k(l * 0.01, i);
  let h = n, f = r;
  for (; h < 0; )
    h += Math.PI * 2, f += Math.PI * 2;
  f - h > Math.PI * 2 && (h = 0, f = Math.PI * 2);
  const d = (f - h) / i.curveStepCount, g = [];
  for (let m = h; m <= f; m = m + d)
    g.push([a + u * Math.cos(m), c + l * Math.sin(m)]);
  return g.push([a + u * Math.cos(f), c + l * Math.sin(f)]), g.push([a, c]), V([g], i);
}
function Ot(o, e) {
  return k(o, e);
}
function Et(o, e, s) {
  return me(o, e, s);
}
function Rt(o, e, s, t, n) {
  return H(o, e, s, t, n, !0);
}
function We(o) {
  const e = Object.assign({}, o);
  return e.randomizer = void 0, o.seed && (e.seed = o.seed + 1), e;
}
function Ke(o) {
  return o.randomizer || (o.randomizer = new vt(o.seed || 0)), o.randomizer.next();
}
function me(o, e, s, t = 1) {
  return s.roughness * t * (Ke(s) * (e - o) + o);
}
function k(o, e, s = 1) {
  return me(-o, o, e, s);
}
function H(o, e, s, t, n, r = !1) {
  const i = r ? n.disableMultiStrokeFill : n.disableMultiStroke, a = Ee(o, e, s, t, n, !0, !1);
  if (i)
    return a;
  const c = Ee(o, e, s, t, n, !0, !0);
  return a.concat(c);
}
function Ee(o, e, s, t, n, r, i) {
  const a = Math.pow(o - s, 2) + Math.pow(e - t, 2), c = Math.sqrt(a);
  let u = 1;
  c < 200 ? u = 1 : c > 500 ? u = 0.4 : u = -16668e-7 * c + 1.233334;
  let l = n.maxRandomnessOffset || 0;
  l * l * 100 > a && (l = c / 10);
  const h = l / 2, f = 0.2 + Ke(n) * 0.2;
  let d = n.bowing * n.maxRandomnessOffset * (t - e) / 200, g = n.bowing * n.maxRandomnessOffset * (o - s) / 200;
  d = k(d, n, u), g = k(g, n, u);
  const m = [], b = () => k(h, n, u), v = () => k(l, n, u), y = n.preserveVertices;
  return i ? m.push({
    op: "move",
    data: [
      o + (y ? 0 : b()),
      e + (y ? 0 : b())
    ]
  }) : m.push({
    op: "move",
    data: [
      o + (y ? 0 : k(l, n, u)),
      e + (y ? 0 : k(l, n, u))
    ]
  }), i ? m.push({
    op: "bcurveTo",
    data: [
      d + o + (s - o) * f + b(),
      g + e + (t - e) * f + b(),
      d + o + 2 * (s - o) * f + b(),
      g + e + 2 * (t - e) * f + b(),
      s + (y ? 0 : b()),
      t + (y ? 0 : b())
    ]
  }) : m.push({
    op: "bcurveTo",
    data: [
      d + o + (s - o) * f + v(),
      g + e + (t - e) * f + v(),
      d + o + 2 * (s - o) * f + v(),
      g + e + 2 * (t - e) * f + v(),
      s + (y ? 0 : v()),
      t + (y ? 0 : v())
    ]
  }), m;
}
function ue(o, e, s) {
  if (!o.length)
    return [];
  const t = [];
  t.push([
    o[0][0] + k(e, s),
    o[0][1] + k(e, s)
  ]), t.push([
    o[0][0] + k(e, s),
    o[0][1] + k(e, s)
  ]);
  for (let n = 1; n < o.length; n++)
    t.push([
      o[n][0] + k(e, s),
      o[n][1] + k(e, s)
    ]), n === o.length - 1 && t.push([
      o[n][0] + k(e, s),
      o[n][1] + k(e, s)
    ]);
  return ke(t, null, s);
}
function ke(o, e, s) {
  const t = o.length, n = [];
  if (t > 3) {
    const r = [], i = 1 - s.curveTightness;
    n.push({ op: "move", data: [o[1][0], o[1][1]] });
    for (let a = 1; a + 2 < t; a++) {
      const c = o[a];
      r[0] = [c[0], c[1]], r[1] = [c[0] + (i * o[a + 1][0] - i * o[a - 1][0]) / 6, c[1] + (i * o[a + 1][1] - i * o[a - 1][1]) / 6], r[2] = [o[a + 1][0] + (i * o[a][0] - i * o[a + 2][0]) / 6, o[a + 1][1] + (i * o[a][1] - i * o[a + 2][1]) / 6], r[3] = [o[a + 1][0], o[a + 1][1]], n.push({ op: "bcurveTo", data: [r[1][0], r[1][1], r[2][0], r[2][1], r[3][0], r[3][1]] });
    }
  } else t === 3 ? (n.push({ op: "move", data: [o[1][0], o[1][1]] }), n.push({
    op: "bcurveTo",
    data: [
      o[1][0],
      o[1][1],
      o[2][0],
      o[2][1],
      o[2][0],
      o[2][1]
    ]
  })) : t === 2 && n.push(...Ee(o[0][0], o[0][1], o[1][0], o[1][1], s, !0, !0));
  return n;
}
function He(o, e, s, t, n, r, i, a) {
  const c = a.roughness === 0, u = [], l = [];
  if (c) {
    o = o / 4, l.push([
      e + t * Math.cos(-o),
      s + n * Math.sin(-o)
    ]);
    for (let h = 0; h <= Math.PI * 2; h = h + o) {
      const f = [
        e + t * Math.cos(h),
        s + n * Math.sin(h)
      ];
      u.push(f), l.push(f);
    }
    l.push([
      e + t * Math.cos(0),
      s + n * Math.sin(0)
    ]), l.push([
      e + t * Math.cos(o),
      s + n * Math.sin(o)
    ]);
  } else {
    const h = k(0.5, a) - Math.PI / 2;
    l.push([
      k(r, a) + e + 0.9 * t * Math.cos(h - o),
      k(r, a) + s + 0.9 * n * Math.sin(h - o)
    ]);
    const f = Math.PI * 2 + h - 0.01;
    for (let d = h; d < f; d = d + o) {
      const g = [
        k(r, a) + e + t * Math.cos(d),
        k(r, a) + s + n * Math.sin(d)
      ];
      u.push(g), l.push(g);
    }
    l.push([
      k(r, a) + e + t * Math.cos(h + Math.PI * 2 + i * 0.5),
      k(r, a) + s + n * Math.sin(h + Math.PI * 2 + i * 0.5)
    ]), l.push([
      k(r, a) + e + 0.98 * t * Math.cos(h + i),
      k(r, a) + s + 0.98 * n * Math.sin(h + i)
    ]), l.push([
      k(r, a) + e + 0.9 * t * Math.cos(h + i * 0.5),
      k(r, a) + s + 0.9 * n * Math.sin(h + i * 0.5)
    ]);
  }
  return [l, u];
}
function Fe(o, e, s, t, n, r, i, a, c) {
  const u = r + k(0.1, c), l = [];
  l.push([
    k(a, c) + e + 0.9 * t * Math.cos(u - o),
    k(a, c) + s + 0.9 * n * Math.sin(u - o)
  ]);
  for (let h = u; h <= i; h = h + o)
    l.push([
      k(a, c) + e + t * Math.cos(h),
      k(a, c) + s + n * Math.sin(h)
    ]);
  return l.push([
    e + t * Math.cos(i),
    s + n * Math.sin(i)
  ]), l.push([
    e + t * Math.cos(i),
    s + n * Math.sin(i)
  ]), ke(l, null, c);
}
function Ct(o, e, s, t, n, r, i, a) {
  const c = [], u = [a.maxRandomnessOffset || 1, (a.maxRandomnessOffset || 1) + 0.3];
  let l = [0, 0];
  const h = a.disableMultiStroke ? 1 : 2, f = a.preserveVertices;
  for (let d = 0; d < h; d++)
    d === 0 ? c.push({ op: "move", data: [i[0], i[1]] }) : c.push({ op: "move", data: [i[0] + (f ? 0 : k(u[0], a)), i[1] + (f ? 0 : k(u[0], a))] }), l = f ? [n, r] : [n + k(u[d], a), r + k(u[d], a)], c.push({
      op: "bcurveTo",
      data: [
        o + k(u[d], a),
        e + k(u[d], a),
        s + k(u[d], a),
        t + k(u[d], a),
        l[0],
        l[1]
      ]
    });
  return c;
}
function Q(o) {
  return [...o];
}
function qe(o, e = 0) {
  const s = o.length;
  if (s < 3)
    throw new Error("A curve must have at least three points.");
  const t = [];
  if (s === 3)
    t.push(Q(o[0]), Q(o[1]), Q(o[2]), Q(o[2]));
  else {
    const n = [];
    n.push(o[0], o[0]);
    for (let a = 1; a < o.length; a++)
      n.push(o[a]), a === o.length - 1 && n.push(o[a]);
    const r = [], i = 1 - e;
    t.push(Q(n[0]));
    for (let a = 1; a + 2 < n.length; a++) {
      const c = n[a];
      r[0] = [c[0], c[1]], r[1] = [c[0] + (i * n[a + 1][0] - i * n[a - 1][0]) / 6, c[1] + (i * n[a + 1][1] - i * n[a - 1][1]) / 6], r[2] = [n[a + 1][0] + (i * n[a][0] - i * n[a + 2][0]) / 6, n[a + 1][1] + (i * n[a][1] - i * n[a + 2][1]) / 6], r[3] = [n[a + 1][0], n[a + 1][1]], t.push(r[1], r[2], r[3]);
    }
  }
  return t;
}
function Lt(o, e) {
  return Math.sqrt(pe(o, e));
}
function pe(o, e) {
  return Math.pow(o[0] - e[0], 2) + Math.pow(o[1] - e[1], 2);
}
function At(o, e, s) {
  const t = pe(e, s);
  if (t === 0)
    return pe(o, e);
  let n = ((o[0] - e[0]) * (s[0] - e[0]) + (o[1] - e[1]) * (s[1] - e[1])) / t;
  return n = Math.max(0, Math.min(1, n)), pe(o, F(e, s, n));
}
function F(o, e, s) {
  return [
    o[0] + (e[0] - o[0]) * s,
    o[1] + (e[1] - o[1]) * s
  ];
}
function jt(o, e) {
  const s = o[e + 0], t = o[e + 1], n = o[e + 2], r = o[e + 3];
  let i = 3 * t[0] - 2 * s[0] - r[0];
  i *= i;
  let a = 3 * t[1] - 2 * s[1] - r[1];
  a *= a;
  let c = 3 * n[0] - 2 * r[0] - s[0];
  c *= c;
  let u = 3 * n[1] - 2 * r[1] - s[1];
  return u *= u, i < c && (i = c), a < u && (a = u), i + a;
}
function Re(o, e, s, t) {
  const n = t || [];
  if (jt(o, e) < s) {
    const r = o[e + 0];
    n.length ? Lt(n[n.length - 1], r) > 1 && n.push(r) : n.push(r), n.push(o[e + 3]);
  } else {
    const i = o[e + 0], a = o[e + 1], c = o[e + 2], u = o[e + 3], l = F(i, a, 0.5), h = F(a, c, 0.5), f = F(c, u, 0.5), d = F(l, h, 0.5), g = F(h, f, 0.5), m = F(d, g, 0.5);
    Re([i, l, d, m], 0, s, n), Re([m, g, f, u], 0, s, n);
  }
  return n;
}
function $t(o, e) {
  return be(o, 0, o.length, e);
}
function be(o, e, s, t, n) {
  const r = n || [], i = o[e], a = o[s - 1];
  let c = 0, u = 1;
  for (let l = e + 1; l < s - 1; ++l) {
    const h = At(o[l], i, a);
    h > c && (c = h, u = l);
  }
  return Math.sqrt(c) > t ? (be(o, e, u + 1, t, r), be(o, u, s, t, r)) : (r.length || r.push(i), r.push(a)), r;
}
function Ce(o, e = 0.15, s) {
  const t = [], n = (o.length - 1) / 3;
  for (let r = 0; r < n; r++) {
    const i = r * 3;
    Re(o, i, e, t);
  }
  return s && s > 0 ? be(t, 0, t.length, s) : t;
}
function zt(o, e, s) {
  const t = Ae(o), n = Xe(Ze(t)), r = [];
  let i = [], a = [0, 0], c = [];
  const u = () => {
    c.length >= 4 && i.push(...Ce(c, e)), c = [];
  }, l = () => {
    u(), i.length && (r.push(i), i = []);
  };
  for (const { key: f, data: d } of n)
    switch (f) {
      case "M":
        l(), a = [d[0], d[1]], i.push(a);
        break;
      case "L":
        u(), i.push([d[0], d[1]]);
        break;
      case "C":
        if (!c.length) {
          const g = i.length ? i[i.length - 1] : a;
          c.push([g[0], g[1]]);
        }
        c.push([d[0], d[1]]), c.push([d[2], d[3]]), c.push([d[4], d[5]]);
        break;
      case "Z":
        u(), i.push([a[0], a[1]]);
        break;
    }
  if (l(), !s)
    return r;
  const h = [];
  for (const f of r) {
    const d = $t(f, s);
    d.length && h.push(d);
  }
  return h;
}
const L = "none";
class ve {
  constructor(e) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: !1,
      disableMultiStrokeFill: !1,
      preserveVertices: !1,
      fillShapeRoughnessGain: 0.8
    }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return bt();
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, s, t) {
    return { shape: e, sets: s || [], options: t || this.defaultOptions };
  }
  line(e, s, t, n, r) {
    const i = this._o(r);
    return this._d("line", [Qe(e, s, t, n, i)], i);
  }
  rectangle(e, s, t, n, r) {
    const i = this._o(r), a = [], c = Pt(e, s, t, n, i);
    if (i.fill) {
      const u = [[e, s], [e + t, s], [e + t, s + n], [e, s + n]];
      i.fillStyle === "solid" ? a.push(Se([u], i)) : a.push(V([u], i));
    }
    return i.stroke !== L && a.push(c), this._d("rectangle", a, i);
  }
  ellipse(e, s, t, n, r) {
    const i = this._o(r), a = [], c = Je(t, n, i), u = Oe(e, s, i, c);
    if (i.fill)
      if (i.fillStyle === "solid") {
        const l = Oe(e, s, i, c).opset;
        l.type = "fillPath", a.push(l);
      } else
        a.push(V([u.estimatedPoints], i));
    return i.stroke !== L && a.push(u.opset), this._d("ellipse", a, i);
  }
  circle(e, s, t, n) {
    const r = this.ellipse(e, s, t, t, n);
    return r.shape = "circle", r;
  }
  linearPath(e, s) {
    const t = this._o(s);
    return this._d("linearPath", [de(e, !1, t)], t);
  }
  arc(e, s, t, n, r, i, a = !1, c) {
    const u = this._o(c), l = [], h = Ie(e, s, t, n, r, i, a, !0, u);
    if (a && u.fill)
      if (u.fillStyle === "solid") {
        const f = Object.assign({}, u);
        f.disableMultiStroke = !0;
        const d = Ie(e, s, t, n, r, i, !0, !1, f);
        d.type = "fillPath", l.push(d);
      } else
        l.push(xt(e, s, t, n, r, i, u));
    return u.stroke !== L && l.push(h), this._d("arc", l, u);
  }
  curve(e, s) {
    const t = this._o(s), n = [], r = De(e, t);
    if (t.fill && t.fill !== L)
      if (t.fillStyle === "solid") {
        const i = De(e, Object.assign(Object.assign({}, t), { disableMultiStroke: !0, roughness: t.roughness ? t.roughness + t.fillShapeRoughnessGain : 0 }));
        n.push({
          type: "fillPath",
          ops: this._mergedShape(i.ops)
        });
      } else {
        const i = [], a = e;
        if (a.length) {
          const u = typeof a[0][0] == "number" ? [a] : a;
          for (const l of u)
            l.length < 3 ? i.push(...l) : l.length === 3 ? i.push(...Ce(qe([
              l[0],
              l[0],
              l[1],
              l[2]
            ]), 10, (1 + t.roughness) / 2)) : i.push(...Ce(qe(l), 10, (1 + t.roughness) / 2));
        }
        i.length && n.push(V([i], t));
      }
    return t.stroke !== L && n.push(r), this._d("curve", n, t);
  }
  polygon(e, s) {
    const t = this._o(s), n = [], r = de(e, !0, t);
    return t.fill && (t.fillStyle === "solid" ? n.push(Se([e], t)) : n.push(V([e], t))), t.stroke !== L && n.push(r), this._d("polygon", n, t);
  }
  path(e, s) {
    const t = this._o(s), n = [];
    if (!e)
      return this._d("path", n, t);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const r = t.fill && t.fill !== "transparent" && t.fill !== L, i = t.stroke !== L, a = !!(t.simplification && t.simplification < 1), c = a ? 4 - 4 * (t.simplification || 1) : (1 + t.roughness) / 2, u = zt(e, 1, c), l = Ne(e, t);
    if (r)
      if (t.fillStyle === "solid")
        if (u.length === 1) {
          const h = Ne(e, Object.assign(Object.assign({}, t), { disableMultiStroke: !0, roughness: t.roughness ? t.roughness + t.fillShapeRoughnessGain : 0 }));
          n.push({
            type: "fillPath",
            ops: this._mergedShape(h.ops)
          });
        } else
          n.push(Se(u, t));
      else
        n.push(V(u, t));
    return i && (a ? u.forEach((h) => {
      n.push(de(h, !1, t));
    }) : n.push(l)), this._d("path", n, t);
  }
  opsToPath(e, s) {
    let t = "";
    for (const n of e.ops) {
      const r = typeof s == "number" && s >= 0 ? n.data.map((i) => +i.toFixed(s)) : n.data;
      switch (n.op) {
        case "move":
          t += `M${r[0]} ${r[1]} `;
          break;
        case "bcurveTo":
          t += `C${r[0]} ${r[1]}, ${r[2]} ${r[3]}, ${r[4]} ${r[5]} `;
          break;
        case "lineTo":
          t += `L${r[0]} ${r[1]} `;
          break;
      }
    }
    return t.trim();
  }
  toPaths(e) {
    const s = e.sets || [], t = e.options || this.defaultOptions, n = [];
    for (const r of s) {
      let i = null;
      switch (r.type) {
        case "path":
          i = {
            d: this.opsToPath(r),
            stroke: t.stroke,
            strokeWidth: t.strokeWidth,
            fill: L
          };
          break;
        case "fillPath":
          i = {
            d: this.opsToPath(r),
            stroke: L,
            strokeWidth: 0,
            fill: t.fill || L
          };
          break;
        case "fillSketch":
          i = this.fillSketch(r, t);
          break;
      }
      i && n.push(i);
    }
    return n;
  }
  fillSketch(e, s) {
    let t = s.fillWeight;
    return t < 0 && (t = s.strokeWidth / 2), {
      d: this.opsToPath(e),
      stroke: s.fill || L,
      strokeWidth: t,
      fill: L
    };
  }
  _mergedShape(e) {
    return e.filter((s, t) => t === 0 ? !0 : s.op !== "move");
  }
}
class Dt {
  constructor(e, s) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new ve(s);
  }
  draw(e) {
    const s = e.sets || [], t = e.options || this.getDefaultOptions(), n = this.ctx, r = e.options.fixedDecimalPlaceDigits;
    for (const i of s)
      switch (i.type) {
        case "path":
          n.save(), n.strokeStyle = t.stroke === "none" ? "transparent" : t.stroke, n.lineWidth = t.strokeWidth, t.strokeLineDash && n.setLineDash(t.strokeLineDash), t.strokeLineDashOffset && (n.lineDashOffset = t.strokeLineDashOffset), this._drawToContext(n, i, r), n.restore();
          break;
        case "fillPath": {
          n.save(), n.fillStyle = t.fill || "";
          const a = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(n, i, r, a), n.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(n, i, t);
          break;
      }
  }
  fillSketch(e, s, t) {
    let n = t.fillWeight;
    n < 0 && (n = t.strokeWidth / 2), e.save(), t.fillLineDash && e.setLineDash(t.fillLineDash), t.fillLineDashOffset && (e.lineDashOffset = t.fillLineDashOffset), e.strokeStyle = t.fill || "", e.lineWidth = n, this._drawToContext(e, s, t.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, s, t, n = "nonzero") {
    e.beginPath();
    for (const r of s.ops) {
      const i = typeof t == "number" && t >= 0 ? r.data.map((a) => +a.toFixed(t)) : r.data;
      switch (r.op) {
        case "move":
          e.moveTo(i[0], i[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
          break;
        case "lineTo":
          e.lineTo(i[0], i[1]);
          break;
      }
    }
    s.type === "fillPath" ? e.fill(n) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, s, t, n, r) {
    const i = this.gen.line(e, s, t, n, r);
    return this.draw(i), i;
  }
  rectangle(e, s, t, n, r) {
    const i = this.gen.rectangle(e, s, t, n, r);
    return this.draw(i), i;
  }
  ellipse(e, s, t, n, r) {
    const i = this.gen.ellipse(e, s, t, n, r);
    return this.draw(i), i;
  }
  circle(e, s, t, n) {
    const r = this.gen.circle(e, s, t, n);
    return this.draw(r), r;
  }
  linearPath(e, s) {
    const t = this.gen.linearPath(e, s);
    return this.draw(t), t;
  }
  polygon(e, s) {
    const t = this.gen.polygon(e, s);
    return this.draw(t), t;
  }
  arc(e, s, t, n, r, i, a = !1, c) {
    const u = this.gen.arc(e, s, t, n, r, i, a, c);
    return this.draw(u), u;
  }
  curve(e, s) {
    const t = this.gen.curve(e, s);
    return this.draw(t), t;
  }
  path(e, s) {
    const t = this.gen.path(e, s);
    return this.draw(t), t;
  }
}
const he = "http://www.w3.org/2000/svg";
class It {
  constructor(e, s) {
    this.svg = e, this.gen = new ve(s);
  }
  draw(e) {
    const s = e.sets || [], t = e.options || this.getDefaultOptions(), n = this.svg.ownerDocument || window.document, r = n.createElementNS(he, "g"), i = e.options.fixedDecimalPlaceDigits;
    for (const a of s) {
      let c = null;
      switch (a.type) {
        case "path": {
          c = n.createElementNS(he, "path"), c.setAttribute("d", this.opsToPath(a, i)), c.setAttribute("stroke", t.stroke), c.setAttribute("stroke-width", t.strokeWidth + ""), c.setAttribute("fill", "none"), t.strokeLineDash && c.setAttribute("stroke-dasharray", t.strokeLineDash.join(" ").trim()), t.strokeLineDashOffset && c.setAttribute("stroke-dashoffset", `${t.strokeLineDashOffset}`);
          break;
        }
        case "fillPath": {
          c = n.createElementNS(he, "path"), c.setAttribute("d", this.opsToPath(a, i)), c.setAttribute("stroke", "none"), c.setAttribute("stroke-width", "0"), c.setAttribute("fill", t.fill || ""), (e.shape === "curve" || e.shape === "polygon") && c.setAttribute("fill-rule", "evenodd");
          break;
        }
        case "fillSketch": {
          c = this.fillSketch(n, a, t);
          break;
        }
      }
      c && r.appendChild(c);
    }
    return r;
  }
  fillSketch(e, s, t) {
    let n = t.fillWeight;
    n < 0 && (n = t.strokeWidth / 2);
    const r = e.createElementNS(he, "path");
    return r.setAttribute("d", this.opsToPath(s, t.fixedDecimalPlaceDigits)), r.setAttribute("stroke", t.fill || ""), r.setAttribute("stroke-width", n + ""), r.setAttribute("fill", "none"), t.fillLineDash && r.setAttribute("stroke-dasharray", t.fillLineDash.join(" ").trim()), t.fillLineDashOffset && r.setAttribute("stroke-dashoffset", `${t.fillLineDashOffset}`), r;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, s) {
    return this.gen.opsToPath(e, s);
  }
  line(e, s, t, n, r) {
    const i = this.gen.line(e, s, t, n, r);
    return this.draw(i);
  }
  rectangle(e, s, t, n, r) {
    const i = this.gen.rectangle(e, s, t, n, r);
    return this.draw(i);
  }
  ellipse(e, s, t, n, r) {
    const i = this.gen.ellipse(e, s, t, n, r);
    return this.draw(i);
  }
  circle(e, s, t, n) {
    const r = this.gen.circle(e, s, t, n);
    return this.draw(r);
  }
  linearPath(e, s) {
    const t = this.gen.linearPath(e, s);
    return this.draw(t);
  }
  polygon(e, s) {
    const t = this.gen.polygon(e, s);
    return this.draw(t);
  }
  arc(e, s, t, n, r, i, a = !1, c) {
    const u = this.gen.arc(e, s, t, n, r, i, a, c);
    return this.draw(u);
  }
  curve(e, s) {
    const t = this.gen.curve(e, s);
    return this.draw(t);
  }
  path(e, s) {
    const t = this.gen.path(e, s);
    return this.draw(t);
  }
}
const A = {
  canvas(o, e) {
    return new Dt(o, e);
  },
  svg(o, e) {
    return new It(o, e);
  },
  generator(o) {
    return new ve(o);
  },
  newSeed() {
    return ve.newSeed();
  }
}, K = (o, e, s, t, n) => `M${o + n},${e} 
          H${o + s - n} 
          A${n},${n} 0 0 1 ${o + s},${e + n} 
          V${e + t - n} 
          A${n},${n} 0 0 1 ${o + s - n},${e + t} 
          H${o + n} 
          A${n},${n} 0 0 1 ${o},${e + t - n} 
          V${e + n} 
          A${n},${n} 0 0 1 ${o + n},${e} 
          Z`, Nt = {
  "drawui-button": "_drawui-button_1nx7z_1"
}, ge = {
  stroke: {
    thin: {
      color: "#333",
      width: 1.5
    },
    medium: {
      color: "#333",
      width: 2.5
    },
    thick: {
      color: "#333",
      width: 4
    }
  },
  roughness: {
    roughness: 3,
    bowing: 2
  },
  fill: {
    background: "#ccccccff"
  },
  radius: {
    none: 0,
    sm: 6,
    md: 10,
    lg: 16,
    full: 30
  },
  buttonSize: {
    sm: {
      width: 100,
      height: 40,
      fontSize: 12
    },
    md: {
      width: 130,
      height: 50,
      fontSize: 15
    },
    lg: {
      width: 150,
      height: 60,
      fontSize: 18
    },
    xl: {
      width: 170,
      height: 70,
      fontSize: 20
    }
  },
  inputSize: {
    sm: {
      height: 32,
      fontSize: 12,
      paddingX: 8
    },
    md: {
      height: 40,
      fontSize: 14,
      paddingX: 12
    },
    lg: {
      height: 48,
      fontSize: 16,
      paddingX: 16
    },
    xl: {
      height: 48,
      fontSize: 16,
      paddingX: 16
    }
  }
}, et = nt(ge), Gt = ({ theme: o, children: e }) => {
  const s = {
    ...ge,
    ...o,
    stroke: {
      ...ge.stroke,
      ...o?.stroke
    },
    radius: {
      ...ge.radius,
      ...o?.radius
    }
  };
  return /* @__PURE__ */ M.jsx(et.Provider, { value: s, children: e });
}, j = () => rt(et), Vt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  size: s = "sm",
  backgroundColor: t,
  children: n,
  fillStyle: r,
  ...i
}) => {
  const a = j(), c = O(null), [u, l] = Y(!1), h = a.buttonSize[s].width, f = a.buttonSize[s].height, d = a.buttonSize[s].fontSize;
  return R(() => {
    if (!c.current) return;
    const g = A.svg(c.current);
    c.current.innerHTML = "";
    const m = a.stroke[o], b = g.path(
      K(0, 0, h, f, a.radius[e]),
      {
        stroke: m.color,
        strokeWidth: m.width,
        fill: t ?? a.fill.background,
        fillStyle: r,
        roughness: u ? a.roughness.roughness + 1 : a.roughness.roughness,
        bowing: a.roughness.bowing
      }
    );
    c.current.appendChild(b);
  }, [u, o, e, a]), /* @__PURE__ */ M.jsxs(
    "button",
    {
      ...i,
      onMouseEnter: () => l(!0),
      onMouseLeave: () => l(!1),
      className: `${Nt["drawui-button"]} ${i.className ?? ""}`,
      style: {
        position: "relative",
        width: h,
        height: f,
        border: "none",
        background: "transparent",
        cursor: "pointer"
      },
      children: [
        /* @__PURE__ */ M.jsx(
          "svg",
          {
            ref: c,
            width: h,
            height: f,
            style: { position: "absolute", inset: 0 }
          }
        ),
        /* @__PURE__ */ M.jsx(
          "span",
          {
            style: {
              position: "relative",
              fontSize: d,
              pointerEvents: "none"
            },
            children: n
          }
        )
      ]
    }
  );
}, fe = {
  "drawui-card": "_drawui-card_vhoat_1",
  "drawui-card-header": "_drawui-card-header_vhoat_7",
  "drawui-card-body": "_drawui-card-body_vhoat_12",
  "drawui-card-footer": "_drawui-card-footer_vhoat_17"
}, Wt = "_vertical_1tdom_6", Ht = "_horizontal_1tdom_11", Pe = {
  "drawui-divider": "_drawui-divider_1tdom_1",
  vertical: Wt,
  horizontal: Ht
}, Ge = ({
  strokeWeight: o = "medium",
  width: e = "100%",
  vertical: s = !1,
  className: t,
  fillStyle: n
}) => {
  const r = j(), i = O(null);
  return R(() => {
    if (!i.current) return;
    i.current.innerHTML = "";
    const a = A.svg(i.current), c = r.stroke[o];
    if (s) {
      const u = typeof e == "number" ? e : 100, l = a.line(0, 0, 0, u, {
        stroke: c.color,
        strokeWidth: c.width,
        roughness: r.roughness.roughness,
        bowing: r.roughness.bowing
      });
      i.current.appendChild(l);
    } else {
      const u = typeof e == "number" ? e : 300, l = a.line(0, 0, u, 0, {
        stroke: c.color,
        strokeWidth: c.width,
        roughness: r.roughness.roughness,
        bowing: r.roughness.bowing,
        fillStyle: n
      });
      i.current.appendChild(l);
    }
  }, [r, o, e, s]), /* @__PURE__ */ M.jsx(
    "div",
    {
      className: `${Pe["drawui-divider"]} ${s ? Pe.vertical : Pe.horizontal} ${t ?? ""}`,
      style: { width: s ? void 0 : e },
      children: /* @__PURE__ */ M.jsx(
        "svg",
        {
          ref: i,
          width: s ? 2 : e,
          height: s ? e : 2,
          style: { display: "block" }
        }
      )
    }
  );
}, Yt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  width: s = 300,
  height: t,
  //optional, card adjust height itself by content
  backgroundColor: n,
  header: r,
  footer: i,
  fillStyle: a,
  children: c,
  ...u
}) => {
  const l = j(), h = O(null), f = O(null), [d, g] = Y(!1), [m, b] = Y(t ?? 200);
  R(() => {
    if (!f.current || t) return;
    const y = () => {
      if (f.current) {
        const z = f.current.scrollHeight;
        b(z);
      }
    };
    y();
    const C = new ResizeObserver(y);
    return C.observe(f.current), () => C.disconnect();
  }, [c, r, i, t]), R(() => {
    if (!h.current) return;
    const y = A.svg(h.current);
    h.current.innerHTML = "";
    const C = l.stroke[o], z = t ?? m, N = y.path(
      K(0, 0, s, z, l.radius[e]),
      {
        stroke: C.color,
        strokeWidth: C.width,
        fill: n ?? l.fill.background,
        roughness: d ? l.roughness.roughness + 1 : l.roughness.roughness,
        bowing: l.roughness.bowing,
        fillStyle: a
      }
    );
    h.current.appendChild(N);
  }, [
    o,
    e,
    s,
    m,
    t,
    n,
    l,
    d,
    a
  ]);
  const v = t ?? m;
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      ...u,
      ref: f,
      className: `${fe["drawui-card"]} ${u.className ?? ""}`,
      onMouseEnter: () => g(!0),
      onMouseLeave: () => g(!1),
      style: {
        position: "relative",
        width: s,
        minHeight: t || "auto",
        height: t || "auto",
        cursor: "default",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ M.jsx(
          "svg",
          {
            ref: h,
            width: s,
            height: v,
            style: { position: "absolute", inset: 0, pointerEvents: "none" }
          }
        ),
        r && /* @__PURE__ */ M.jsxs(M.Fragment, { children: [
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: fe["drawui-card-header"],
              style: { position: "relative", zIndex: 1 },
              children: r
            }
          ),
          /* @__PURE__ */ M.jsx(Ge, { width: s, strokeWeight: "thick" })
        ] }),
        /* @__PURE__ */ M.jsx(
          "div",
          {
            className: fe["drawui-card-body"],
            style: { position: "relative", zIndex: 1, flex: 1 },
            children: c
          }
        ),
        i && /* @__PURE__ */ M.jsxs(M.Fragment, { children: [
          /* @__PURE__ */ M.jsx(Ge, { width: s, strokeWeight: "thick" }),
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: fe["drawui-card-footer"],
              style: { position: "relative", zIndex: 1 },
              children: i
            }
          )
        ] })
      ]
    }
  );
}, Ve = {
  "drawui-collapse": "_drawui-collapse_mgu8u_1",
  "drawui-collapse-content": "_drawui-collapse-content_mgu8u_22"
}, Bt = ({
  header: o,
  children: e,
  strokeWeight: s = "medium",
  radius: t = "md",
  width: n = 300,
  fillStyle: r,
  className: i
}) => {
  const a = j(), c = O(null);
  return R(() => {
    if (!c.current) return;
    const u = A.svg(c.current);
    c.current.innerHTML = "";
    const l = a.stroke[s], h = u.path(
      K(0, 0, n, 40, a.radius[t]),
      {
        stroke: l.color,
        strokeWidth: l.width,
        fill: "transparent",
        roughness: a.roughness.roughness,
        bowing: a.roughness.bowing,
        fillStyle: r
      }
    );
    c.current.appendChild(h);
  }, [a, s, t, n]), /* @__PURE__ */ M.jsx("div", { className: `${Ve["drawui-collapse"]} ${i ?? ""}`, style: { width: n }, children: /* @__PURE__ */ M.jsxs("details", { children: [
    /* @__PURE__ */ M.jsxs("summary", { style: { position: "relative" }, children: [
      /* @__PURE__ */ M.jsx(
        "svg",
        {
          ref: c,
          width: n,
          height: 40,
          style: { position: "absolute", inset: 0, pointerEvents: "none" }
        }
      ),
      /* @__PURE__ */ M.jsx("span", { style: { position: "relative", zIndex: 1 }, children: o })
    ] }),
    /* @__PURE__ */ M.jsx("div", { className: Ve["drawui-collapse-content"], children: e })
  ] }) });
}, Ft = {}, Zt = ({
  strokeWeight: o = "medium",
  radius: e = "md",
  size: s = "sm",
  icon: t,
  fillStyle: n,
  backgroundColor: r,
  ...i
}) => {
  const a = j(), c = O(null), [u, l] = Y(!1), h = a.buttonSize[s].height;
  return R(() => {
    if (!c.current) return;
    const f = A.svg(c.current);
    c.current.innerHTML = "";
    const d = a.stroke[o], g = f.path(
      K(0, 0, h, h, a.radius[e]),
      {
        stroke: d.color,
        strokeWidth: d.width,
        fill: r ?? a.fill.background,
        roughness: u ? a.roughness.roughness + 1 : a.roughness.roughness,
        bowing: a.roughness.bowing,
        fillStyle: n
      }
    );
    c.current.appendChild(g);
  }, [u, o, e, a, h, r]), /* @__PURE__ */ M.jsxs(
    "button",
    {
      ...i,
      onMouseEnter: () => l(!0),
      onMouseLeave: () => l(!1),
      className: `${Ft["drawui-button"]} ${i.className ?? ""}`,
      style: {
        position: "relative",
        width: h,
        height: h,
        // height and width are equal
        border: "none",
        background: "transparent",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        padding: 0
      },
      children: [
        /* @__PURE__ */ M.jsx(
          "svg",
          {
            ref: c,
            width: h,
            height: h,
            style: {
              position: "absolute",
              inset: 0,
              pointerEvents: "none"
            }
          }
        ),
        /* @__PURE__ */ M.jsx(
          "span",
          {
            style: {
              position: "relative",
              pointerEvents: "none",
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            children: t
          }
        )
      ]
    }
  );
}, Ye = {
  "drawui-input": "_drawui-input_15az9_1",
  "drawui-input-field": "_drawui-input-field_15az9_8"
}, Xt = ({
  strokeWeight: o = "medium",
  backgroundColor: e,
  radius: s = "md",
  inputSize: t = "md",
  className: n,
  fillStyle: r,
  style: i,
  ...a
}) => {
  const c = j(), u = O(null), l = O(null), [h, f] = Y(!1), [d, g] = Y(!1), m = c.inputSize[t].height, b = c.inputSize[t].fontSize, v = c.inputSize[t].paddingX;
  return R(() => {
    if (!u.current || !l.current) return;
    const y = l.current.offsetWidth, C = A.svg(u.current);
    u.current.innerHTML = "";
    const z = c.stroke[o], N = C.path(
      K(0, 0, y, m, c.radius[s]),
      {
        stroke: z.color,
        strokeWidth: z.width,
        fill: e ?? c.fill.background,
        roughness: h ? c.roughness.roughness + 1 : c.roughness.roughness,
        bowing: c.roughness.bowing,
        fillStyle: r
      }
    );
    u.current.appendChild(N);
  }, [h, d, o, s, t, c, e]), /* @__PURE__ */ M.jsxs(
    "div",
    {
      ref: l,
      className: `${Ye["drawui-input"]} ${n ?? ""}`,
      style: { height: m, ...i },
      onMouseEnter: () => g(!0),
      onMouseLeave: () => g(!1),
      children: [
        /* @__PURE__ */ M.jsx(
          "svg",
          {
            ref: u,
            width: "100%",
            height: m,
            style: { position: "absolute", inset: 0 }
          }
        ),
        /* @__PURE__ */ M.jsx(
          "input",
          {
            ...a,
            className: Ye["drawui-input-field"],
            style: {
              height: m,
              fontSize: b,
              paddingLeft: v,
              paddingRight: v
            },
            onFocus: (y) => {
              f(!0), a.onFocus?.(y);
            },
            onBlur: (y) => {
              f(!1), a.onBlur?.(y);
            }
          }
        )
      ]
    }
  );
}, Ut = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.path(
      "M6 18 H18 L16 12 A6 6 0 0 0 8 12 Z",
      {
        stroke: c,
        strokeWidth: a.width,
        roughness: n.roughness.roughness,
        bowing: n.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(u);
    const l = i.circle(12, 18, 2, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(l);
  }, [n, e, s]), /* @__PURE__ */ M.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: t });
}, Qt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.path(
      "M2 12 L12 2 L22 12 V22 H2 Z",
      {
        stroke: c,
        strokeWidth: a.width,
        roughness: n.roughness.roughness,
        bowing: n.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(u);
  }, [n, e, s]), /* @__PURE__ */ M.jsx(
    "svg",
    {
      ref: r,
      width: o,
      height: o,
      viewBox: "0 0 24 24",
      className: t
    }
  );
}, Jt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.line(4, 12, 20, 12, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing
    });
    r.current.appendChild(u);
  }, [n, e, s]), /* @__PURE__ */ M.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: t });
}, Kt = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.line(12, 4, 12, 20, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing
    }), l = i.line(4, 12, 20, 12, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing
    });
    r.current.appendChild(u), r.current.appendChild(l);
  }, [n, e, s]), /* @__PURE__ */ M.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: t });
}, es = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.circle(10, 10, 14, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing,
      fill: "transparent"
    }), l = i.line(16, 16, 22, 22, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing
    });
    r.current.appendChild(u), r.current.appendChild(l);
  }, [n, e, s]), /* @__PURE__ */ M.jsx(
    "svg",
    {
      ref: r,
      width: o,
      height: o,
      viewBox: "0 0 24 24",
      className: t
    }
  );
}, ts = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.circle(12, 12, 14, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(u);
    for (let l = 0; l < 8; l++) {
      const h = l * Math.PI * 2 / 8, f = 12 + 7 * Math.cos(h), d = 12 + 7 * Math.sin(h), g = 12 + 10 * Math.cos(h), m = 12 + 10 * Math.sin(h), b = i.line(f, d, g, m, {
        stroke: c,
        strokeWidth: a.width,
        roughness: n.roughness.roughness,
        bowing: n.roughness.bowing
      });
      r.current.appendChild(b);
    }
  }, [n, e, s]), /* @__PURE__ */ M.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: t });
}, ss = ({
  size: o = 24,
  strokeWeight: e = "medium",
  color: s,
  className: t
}) => {
  const n = j(), r = O(null);
  return R(() => {
    if (!r.current) return;
    const i = A.svg(r.current);
    r.current.innerHTML = "";
    const a = n.stroke[e], c = s ?? a.color, u = i.circle(12, 8, 6, {
      stroke: c,
      strokeWidth: a.width,
      roughness: n.roughness.roughness,
      bowing: n.roughness.bowing,
      fill: "transparent"
    });
    r.current.appendChild(u);
    const l = i.path(
      "M4 20 Q12 16 20 20",
      {
        stroke: c,
        strokeWidth: a.width,
        roughness: n.roughness.roughness,
        bowing: n.roughness.bowing,
        fill: "transparent"
      }
    );
    r.current.appendChild(l);
  }, [n, e, s]), /* @__PURE__ */ M.jsx("svg", { ref: r, width: o, height: o, viewBox: "0 0 24 24", className: t });
};
export {
  Vt as DrawuiButton,
  Yt as DrawuiCard,
  Bt as DrawuiCollapse,
  Ge as DrawuiDivider,
  Zt as DrawuiIconButton,
  Xt as DrawuiInput,
  Gt as DrawuiThemeProvider,
  Ut as IconBell,
  Qt as IconHome,
  Jt as IconMinus,
  Kt as IconPlus,
  es as IconSearch,
  ts as IconSettings,
  ss as IconUser,
  j as useDrawuiTheme
};
